/* tslint:disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v{{VERSION}}
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "test-lib";
import * as __ROOT_NAMESPACE__ from "./../../..";
import * as com_test_operation from "./../operation";
import * as NotAGoodIdea from "./NotAGoodIdea";
import * as Work from "./Work";
import * as Choice from "./Choice";
import * as com_test_common from "./../common";
import * as CommonStruct from "./CommonStruct";
import * as TypedMap from "./TypedMap";
export const metadata: thrift.IServiceMetadata = {
    name: "Calculator",
    annotations: {},
    methods: {
        getUnion: {
            name: "getUnion",
            annotations: {},
            arguments: [
                {
                    name: "index",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        getEnum: {
            name: "getEnum",
            annotations: {},
            arguments: []
        },
        getStruct: {
            name: "getStruct",
            annotations: {},
            arguments: [
                {
                    name: "key",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        ping: {
            name: "ping",
            annotations: {},
            arguments: []
        },
        add: {
            name: "add",
            annotations: {},
            arguments: [
                {
                    name: "num1",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                },
                {
                    name: "num2",
                    fieldId: 2,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        addInt64: {
            name: "addInt64",
            annotations: {},
            arguments: [
                {
                    name: "num1",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                },
                {
                    name: "num2",
                    fieldId: 2,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        addWithContext: {
            name: "addWithContext",
            annotations: {},
            arguments: [
                {
                    name: "num1",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                },
                {
                    name: "num2",
                    fieldId: 2,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        calculate: {
            name: "calculate",
            annotations: {},
            arguments: [
                {
                    name: "logid",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                },
                {
                    name: "work",
                    fieldId: 2,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.StructType,
                        name: "Work",
                        annotations: {},
                        fields: {
                            num1: {
                                name: "num1",
                                fieldId: 1,
                                annotations: {},
                                definitionType: {
                                    type: thrift.DefinitionMetadataType.BaseType
                                }
                            },
                            num2: {
                                name: "num2",
                                fieldId: 2,
                                annotations: {},
                                definitionType: {
                                    type: thrift.DefinitionMetadataType.BaseType
                                }
                            },
                            op: {
                                name: "op",
                                fieldId: 3,
                                annotations: {},
                                definitionType: {
                                    type: thrift.DefinitionMetadataType.BaseType
                                }
                            },
                            comment: {
                                name: "comment",
                                fieldId: 4,
                                annotations: {},
                                definitionType: {
                                    type: thrift.DefinitionMetadataType.BaseType
                                }
                            }
                        }
                    }
                }
            ]
        },
        echoBinary: {
            name: "echoBinary",
            annotations: {},
            arguments: [
                {
                    name: "word",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        echoString: {
            name: "echoString",
            annotations: {},
            arguments: [
                {
                    name: "word",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        checkName: {
            name: "checkName",
            annotations: {},
            arguments: [
                {
                    name: "choice",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.StructType,
                        name: "Choice",
                        annotations: {},
                        fields: {
                            firstName: {
                                name: "firstName",
                                fieldId: 1,
                                annotations: {},
                                definitionType: {
                                    type: thrift.DefinitionMetadataType.StructType,
                                    name: "FirstName",
                                    annotations: {},
                                    fields: {
                                        name: {
                                            name: "name",
                                            fieldId: 1,
                                            annotations: {},
                                            definitionType: {
                                                type: thrift.DefinitionMetadataType.BaseType
                                            }
                                        }
                                    }
                                }
                            },
                            lastName: {
                                name: "lastName",
                                fieldId: 2,
                                annotations: {},
                                definitionType: {
                                    type: thrift.DefinitionMetadataType.StructType,
                                    name: "LastName",
                                    annotations: {},
                                    fields: {
                                        name: {
                                            name: "name",
                                            fieldId: 1,
                                            annotations: {},
                                            definitionType: {
                                                type: thrift.DefinitionMetadataType.BaseType
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            ]
        },
        checkOptional: {
            name: "checkOptional",
            annotations: {},
            arguments: [
                {
                    name: "type",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        mapOneList: {
            name: "mapOneList",
            annotations: {},
            arguments: [
                {
                    name: "arg",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        mapValues: {
            name: "mapValues",
            annotations: {},
            arguments: [
                {
                    name: "arg",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        listToMap: {
            name: "listToMap",
            annotations: {},
            arguments: [
                {
                    name: "arg",
                    fieldId: 1,
                    annotations: {},
                    definitionType: {
                        type: thrift.DefinitionMetadataType.BaseType
                    }
                }
            ]
        },
        fetchThing: {
            name: "fetchThing",
            annotations: {},
            arguments: []
        },
        fetchMap: {
            name: "fetchMap",
            annotations: {},
            arguments: []
        },
        zip: {
            name: "zip",
            annotations: {},
            arguments: []
        }
    }
};
export interface IPing__Args {
    __name: "Ping__Args";
}
export interface IPing__ArgsArgs {
}
export const Ping__ArgsCodec: thrift.IStructCodec<IPing__ArgsArgs, IPing__Args> = {
    encode(args: IPing__ArgsArgs, output: thrift.TProtocol): void {
        output.writeStructBegin("Ping__Args");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IPing__Args {
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "Ping__Args"
        };
    }
};
export class Ping__Args implements thrift.IStructLike, IPing__Args {
    public readonly __name = "Ping__Args";
    constructor(args: IPing__ArgsArgs = {}) {
    }
    public static read(input: thrift.TProtocol): Ping__Args {
        return new Ping__Args(Ping__ArgsCodec.decode(input));
    }
    public static write(args: IPing__ArgsArgs, output: thrift.TProtocol): void {
        return Ping__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Ping__ArgsCodec.encode(this, output);
    }
}
export interface IAdd__Args {
    __name: "Add__Args";
    num1: number;
    num2: number;
}
export interface IAdd__ArgsArgs {
    num1: number;
    num2: number;
}
export const Add__ArgsCodec: thrift.IStructCodec<IAdd__ArgsArgs, IAdd__Args> = {
    encode(args: IAdd__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            num1: args.num1,
            num2: args.num2
        };
        output.writeStructBegin("Add__Args");
        if (obj.num1 != null) {
            output.writeFieldBegin("num1", thrift.TType.I32, 1);
            output.writeI32(obj.num1);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
        }
        if (obj.num2 != null) {
            output.writeFieldBegin("num2", thrift.TType.I32, 2);
            output.writeI32(obj.num2);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IAdd__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.I32) {
                        const value_1: number = input.readI32();
                        _args.num1 = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.TType.I32) {
                        const value_2: number = input.readI32();
                        _args.num2 = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num1 !== undefined && _args.num2 !== undefined) {
            return {
                __name: "Add__Args",
                num1: _args.num1,
                num2: _args.num2
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read Add__Args from input");
        }
    }
};
export class Add__Args implements thrift.IStructLike, IAdd__Args {
    public num1: number;
    public num2: number;
    public readonly __name = "Add__Args";
    constructor(args: IAdd__ArgsArgs) {
        if (args.num1 != null) {
            const value_3: number = args.num1;
            this.num1 = value_3;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
        }
        if (args.num2 != null) {
            const value_4: number = args.num2;
            this.num2 = value_4;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): Add__Args {
        return new Add__Args(Add__ArgsCodec.decode(input));
    }
    public static write(args: IAdd__ArgsArgs, output: thrift.TProtocol): void {
        return Add__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Add__ArgsCodec.encode(this, output);
    }
}
export interface IAddInt64__Args {
    __name: "AddInt64__Args";
    num1: bigint;
    num2: bigint;
}
export interface IAddInt64__ArgsArgs {
    num1: number | string | bigint;
    num2: number | string | bigint;
}
export const AddInt64__ArgsCodec: thrift.IStructCodec<IAddInt64__ArgsArgs, IAddInt64__Args> = {
    encode(args: IAddInt64__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            num1: (typeof args.num1 === "number" ? BigInt(args.num1) : typeof args.num1 === "string" ? BigInt(args.num1) : args.num1),
            num2: (typeof args.num2 === "number" ? BigInt(args.num2) : typeof args.num2 === "string" ? BigInt(args.num2) : args.num2)
        };
        output.writeStructBegin("AddInt64__Args");
        if (obj.num1 != null) {
            output.writeFieldBegin("num1", thrift.TType.I64, 1);
            output.writeI64((typeof obj.num1 === "number" ? BigInt(obj.num1) : typeof obj.num1 === "string" ? BigInt(obj.num1) : obj.num1));
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
        }
        if (obj.num2 != null) {
            output.writeFieldBegin("num2", thrift.TType.I64, 2);
            output.writeI64((typeof obj.num2 === "number" ? BigInt(obj.num2) : typeof obj.num2 === "string" ? BigInt(obj.num2) : obj.num2));
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IAddInt64__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.I64) {
                        const value_5: bigint = input.readI64();
                        _args.num1 = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.TType.I64) {
                        const value_6: bigint = input.readI64();
                        _args.num2 = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num1 !== undefined && _args.num2 !== undefined) {
            return {
                __name: "AddInt64__Args",
                num1: _args.num1,
                num2: _args.num2
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddInt64__Args from input");
        }
    }
};
export class AddInt64__Args implements thrift.IStructLike, IAddInt64__Args {
    public num1: bigint;
    public num2: bigint;
    public readonly __name = "AddInt64__Args";
    constructor(args: IAddInt64__ArgsArgs) {
        if (args.num1 != null) {
            const value_7: bigint = (typeof args.num1 === "number" ? BigInt(args.num1) : typeof args.num1 === "string" ? BigInt(args.num1) : args.num1);
            this.num1 = value_7;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
        }
        if (args.num2 != null) {
            const value_8: bigint = (typeof args.num2 === "number" ? BigInt(args.num2) : typeof args.num2 === "string" ? BigInt(args.num2) : args.num2);
            this.num2 = value_8;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): AddInt64__Args {
        return new AddInt64__Args(AddInt64__ArgsCodec.decode(input));
    }
    public static write(args: IAddInt64__ArgsArgs, output: thrift.TProtocol): void {
        return AddInt64__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return AddInt64__ArgsCodec.encode(this, output);
    }
}
export interface IAddWithContext__Args {
    __name: "AddWithContext__Args";
    num1: number;
    num2: number;
}
export interface IAddWithContext__ArgsArgs {
    num1: number;
    num2: number;
}
export const AddWithContext__ArgsCodec: thrift.IStructCodec<IAddWithContext__ArgsArgs, IAddWithContext__Args> = {
    encode(args: IAddWithContext__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            num1: args.num1,
            num2: args.num2
        };
        output.writeStructBegin("AddWithContext__Args");
        if (obj.num1 != null) {
            output.writeFieldBegin("num1", thrift.TType.I32, 1);
            output.writeI32(obj.num1);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
        }
        if (obj.num2 != null) {
            output.writeFieldBegin("num2", thrift.TType.I32, 2);
            output.writeI32(obj.num2);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IAddWithContext__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.I32) {
                        const value_9: number = input.readI32();
                        _args.num1 = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.TType.I32) {
                        const value_10: number = input.readI32();
                        _args.num2 = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num1 !== undefined && _args.num2 !== undefined) {
            return {
                __name: "AddWithContext__Args",
                num1: _args.num1,
                num2: _args.num2
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddWithContext__Args from input");
        }
    }
};
export class AddWithContext__Args implements thrift.IStructLike, IAddWithContext__Args {
    public num1: number;
    public num2: number;
    public readonly __name = "AddWithContext__Args";
    constructor(args: IAddWithContext__ArgsArgs) {
        if (args.num1 != null) {
            const value_11: number = args.num1;
            this.num1 = value_11;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
        }
        if (args.num2 != null) {
            const value_12: number = args.num2;
            this.num2 = value_12;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): AddWithContext__Args {
        return new AddWithContext__Args(AddWithContext__ArgsCodec.decode(input));
    }
    public static write(args: IAddWithContext__ArgsArgs, output: thrift.TProtocol): void {
        return AddWithContext__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return AddWithContext__ArgsCodec.encode(this, output);
    }
}
export interface ICalculate__Args {
    __name: "Calculate__Args";
    logid: number;
    work: Work.IWork;
}
export interface ICalculate__ArgsArgs {
    logid: number;
    work: Work.IWorkArgs;
}
export const Calculate__ArgsCodec: thrift.IStructCodec<ICalculate__ArgsArgs, ICalculate__Args> = {
    encode(args: ICalculate__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            logid: args.logid,
            work: args.work
        };
        output.writeStructBegin("Calculate__Args");
        if (obj.logid != null) {
            output.writeFieldBegin("logid", thrift.TType.I32, 1);
            output.writeI32(obj.logid);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[logid] is unset!");
        }
        if (obj.work != null) {
            output.writeFieldBegin("work", thrift.TType.STRUCT, 2);
            Work.WorkCodec.encode(obj.work, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[work] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICalculate__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.I32) {
                        const value_13: number = input.readI32();
                        _args.logid = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_14: Work.IWork = Work.WorkCodec.decode(input);
                        _args.work = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.logid !== undefined && _args.work !== undefined) {
            return {
                __name: "Calculate__Args",
                logid: _args.logid,
                work: _args.work
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read Calculate__Args from input");
        }
    }
};
export class Calculate__Args implements thrift.IStructLike, ICalculate__Args {
    public logid: number;
    public work: Work.IWork;
    public readonly __name = "Calculate__Args";
    constructor(args: ICalculate__ArgsArgs) {
        if (args.logid != null) {
            const value_15: number = args.logid;
            this.logid = value_15;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[logid] is unset!");
        }
        if (args.work != null) {
            const value_16: Work.IWork = new Work.Work(args.work);
            this.work = value_16;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[work] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): Calculate__Args {
        return new Calculate__Args(Calculate__ArgsCodec.decode(input));
    }
    public static write(args: ICalculate__ArgsArgs, output: thrift.TProtocol): void {
        return Calculate__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Calculate__ArgsCodec.encode(this, output);
    }
}
export interface IEchoBinary__Args {
    __name: "EchoBinary__Args";
    word: Buffer;
}
export interface IEchoBinary__ArgsArgs {
    word: string | Buffer;
}
export const EchoBinary__ArgsCodec: thrift.IStructCodec<IEchoBinary__ArgsArgs, IEchoBinary__Args> = {
    encode(args: IEchoBinary__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            word: (typeof args.word === "string" ? Buffer.from(args.word) : args.word)
        };
        output.writeStructBegin("EchoBinary__Args");
        if (obj.word != null) {
            output.writeFieldBegin("word", thrift.TType.STRING, 1);
            output.writeBinary(obj.word);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IEchoBinary__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRING) {
                        const value_17: Buffer = input.readBinary();
                        _args.word = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.word !== undefined) {
            return {
                __name: "EchoBinary__Args",
                word: _args.word
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read EchoBinary__Args from input");
        }
    }
};
export class EchoBinary__Args implements thrift.IStructLike, IEchoBinary__Args {
    public word: Buffer;
    public readonly __name = "EchoBinary__Args";
    constructor(args: IEchoBinary__ArgsArgs) {
        if (args.word != null) {
            const value_18: Buffer = (typeof args.word === "string" ? Buffer.from(args.word) : args.word);
            this.word = value_18;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): EchoBinary__Args {
        return new EchoBinary__Args(EchoBinary__ArgsCodec.decode(input));
    }
    public static write(args: IEchoBinary__ArgsArgs, output: thrift.TProtocol): void {
        return EchoBinary__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return EchoBinary__ArgsCodec.encode(this, output);
    }
}
export interface IEchoString__Args {
    __name: "EchoString__Args";
    word: string;
}
export interface IEchoString__ArgsArgs {
    word: string;
}
export const EchoString__ArgsCodec: thrift.IStructCodec<IEchoString__ArgsArgs, IEchoString__Args> = {
    encode(args: IEchoString__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            word: args.word
        };
        output.writeStructBegin("EchoString__Args");
        if (obj.word != null) {
            output.writeFieldBegin("word", thrift.TType.STRING, 1);
            output.writeString(obj.word);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IEchoString__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRING) {
                        const value_19: string = input.readString();
                        _args.word = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.word !== undefined) {
            return {
                __name: "EchoString__Args",
                word: _args.word
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read EchoString__Args from input");
        }
    }
};
export class EchoString__Args implements thrift.IStructLike, IEchoString__Args {
    public word: string;
    public readonly __name = "EchoString__Args";
    constructor(args: IEchoString__ArgsArgs) {
        if (args.word != null) {
            const value_20: string = args.word;
            this.word = value_20;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): EchoString__Args {
        return new EchoString__Args(EchoString__ArgsCodec.decode(input));
    }
    public static write(args: IEchoString__ArgsArgs, output: thrift.TProtocol): void {
        return EchoString__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return EchoString__ArgsCodec.encode(this, output);
    }
}
export interface ICheckName__Args {
    __name: "CheckName__Args";
    choice: Choice.Choice;
}
export interface ICheckName__ArgsArgs {
    choice: Choice.ChoiceArgs;
}
export const CheckName__ArgsCodec: thrift.IStructCodec<ICheckName__ArgsArgs, ICheckName__Args> = {
    encode(args: ICheckName__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            choice: args.choice
        };
        output.writeStructBegin("CheckName__Args");
        if (obj.choice != null) {
            output.writeFieldBegin("choice", thrift.TType.STRUCT, 1);
            Choice.ChoiceCodec.encode(obj.choice, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[choice] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICheckName__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_21: Choice.Choice = Choice.ChoiceCodec.decode(input);
                        _args.choice = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.choice !== undefined) {
            return {
                __name: "CheckName__Args",
                choice: _args.choice
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CheckName__Args from input");
        }
    }
};
export class CheckName__Args implements thrift.IStructLike, ICheckName__Args {
    public choice: Choice.Choice;
    public readonly __name = "CheckName__Args";
    constructor(args: ICheckName__ArgsArgs) {
        if (args.choice != null) {
            const value_22: Choice.Choice = Choice.ChoiceCodec.create(args.choice);
            this.choice = value_22;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[choice] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): CheckName__Args {
        return new CheckName__Args(CheckName__ArgsCodec.decode(input));
    }
    public static write(args: ICheckName__ArgsArgs, output: thrift.TProtocol): void {
        return CheckName__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CheckName__ArgsCodec.encode(this, output);
    }
}
export interface ICheckOptional__Args {
    __name: "CheckOptional__Args";
    type?: string;
}
export interface ICheckOptional__ArgsArgs {
    type?: string;
}
export const CheckOptional__ArgsCodec: thrift.IStructCodec<ICheckOptional__ArgsArgs, ICheckOptional__Args> = {
    encode(args: ICheckOptional__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            type: args.type
        };
        output.writeStructBegin("CheckOptional__Args");
        if (obj.type != null) {
            output.writeFieldBegin("type", thrift.TType.STRING, 1);
            output.writeString(obj.type);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICheckOptional__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRING) {
                        const value_23: string = input.readString();
                        _args.type = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "CheckOptional__Args",
            type: _args.type
        };
    }
};
export class CheckOptional__Args implements thrift.IStructLike, ICheckOptional__Args {
    public type?: string;
    public readonly __name = "CheckOptional__Args";
    constructor(args: ICheckOptional__ArgsArgs = {}) {
        if (args.type != null) {
            const value_24: string = args.type;
            this.type = value_24;
        }
    }
    public static read(input: thrift.TProtocol): CheckOptional__Args {
        return new CheckOptional__Args(CheckOptional__ArgsCodec.decode(input));
    }
    public static write(args: ICheckOptional__ArgsArgs, output: thrift.TProtocol): void {
        return CheckOptional__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CheckOptional__ArgsCodec.encode(this, output);
    }
}
export interface IMapOneList__Args {
    __name: "MapOneList__Args";
    arg: Array<number>;
}
export interface IMapOneList__ArgsArgs {
    arg: Array<number>;
}
export const MapOneList__ArgsCodec: thrift.IStructCodec<IMapOneList__ArgsArgs, IMapOneList__Args> = {
    encode(args: IMapOneList__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            arg: args.arg
        };
        output.writeStructBegin("MapOneList__Args");
        if (obj.arg != null) {
            output.writeFieldBegin("arg", thrift.TType.LIST, 1);
            output.writeListBegin(thrift.TType.I32, obj.arg.length);
            obj.arg.forEach((value_25: number): void => {
                output.writeI32(value_25);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IMapOneList__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.LIST) {
                        const value_26: Array<number> = new Array<number>();
                        const metadata_1: thrift.IThriftList = input.readListBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_27: number = input.readI32();
                            value_26.push(value_27);
                        }
                        input.readListEnd();
                        _args.arg = value_26;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.arg !== undefined) {
            return {
                __name: "MapOneList__Args",
                arg: _args.arg
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MapOneList__Args from input");
        }
    }
};
export class MapOneList__Args implements thrift.IStructLike, IMapOneList__Args {
    public arg: Array<number>;
    public readonly __name = "MapOneList__Args";
    constructor(args: IMapOneList__ArgsArgs) {
        if (args.arg != null) {
            const value_28: Array<number> = new Array<number>();
            args.arg.forEach((value_29: number): void => {
                const value_30: number = value_29;
                value_28.push(value_30);
            });
            this.arg = value_28;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): MapOneList__Args {
        return new MapOneList__Args(MapOneList__ArgsCodec.decode(input));
    }
    public static write(args: IMapOneList__ArgsArgs, output: thrift.TProtocol): void {
        return MapOneList__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return MapOneList__ArgsCodec.encode(this, output);
    }
}
export interface IMapValues__Args {
    __name: "MapValues__Args";
    arg: Map<string, number>;
}
export interface IMapValues__ArgsArgs {
    arg: Map<string, number>;
}
export const MapValues__ArgsCodec: thrift.IStructCodec<IMapValues__ArgsArgs, IMapValues__Args> = {
    encode(args: IMapValues__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            arg: args.arg
        };
        output.writeStructBegin("MapValues__Args");
        if (obj.arg != null) {
            output.writeFieldBegin("arg", thrift.TType.MAP, 1);
            output.writeMapBegin(thrift.TType.STRING, thrift.TType.I32, obj.arg.size);
            obj.arg.forEach((value_31: number, key_1: string): void => {
                output.writeString(key_1);
                output.writeI32(value_31);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IMapValues__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.MAP) {
                        const value_32: Map<string, number> = new Map<string, number>();
                        const metadata_2: thrift.IThriftMap = input.readMapBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const key_2: string = input.readString();
                            const value_33: number = input.readI32();
                            value_32.set(key_2, value_33);
                        }
                        input.readMapEnd();
                        _args.arg = value_32;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.arg !== undefined) {
            return {
                __name: "MapValues__Args",
                arg: _args.arg
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MapValues__Args from input");
        }
    }
};
export class MapValues__Args implements thrift.IStructLike, IMapValues__Args {
    public arg: Map<string, number>;
    public readonly __name = "MapValues__Args";
    constructor(args: IMapValues__ArgsArgs) {
        if (args.arg != null) {
            const value_34: Map<string, number> = new Map<string, number>();
            args.arg.forEach((value_35: number, key_3: string): void => {
                const value_36: number = value_35;
                const key_4: string = key_3;
                value_34.set(key_4, value_36);
            });
            this.arg = value_34;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): MapValues__Args {
        return new MapValues__Args(MapValues__ArgsCodec.decode(input));
    }
    public static write(args: IMapValues__ArgsArgs, output: thrift.TProtocol): void {
        return MapValues__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return MapValues__ArgsCodec.encode(this, output);
    }
}
export interface IListToMap__Args {
    __name: "ListToMap__Args";
    arg: Array<Array<string>>;
}
export interface IListToMap__ArgsArgs {
    arg: Array<Array<string>>;
}
export const ListToMap__ArgsCodec: thrift.IStructCodec<IListToMap__ArgsArgs, IListToMap__Args> = {
    encode(args: IListToMap__ArgsArgs, output: thrift.TProtocol): void {
        const obj = {
            arg: args.arg
        };
        output.writeStructBegin("ListToMap__Args");
        if (obj.arg != null) {
            output.writeFieldBegin("arg", thrift.TType.LIST, 1);
            output.writeListBegin(thrift.TType.LIST, obj.arg.length);
            obj.arg.forEach((value_37: Array<string>): void => {
                output.writeListBegin(thrift.TType.STRING, value_37.length);
                value_37.forEach((value_38: string): void => {
                    output.writeString(value_38);
                });
                output.writeListEnd();
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IListToMap__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.LIST) {
                        const value_39: Array<Array<string>> = new Array<Array<string>>();
                        const metadata_3: thrift.IThriftList = input.readListBegin();
                        const size_3: number = metadata_3.size;
                        for (let i_3: number = 0; i_3 < size_3; i_3++) {
                            const value_40: Array<string> = new Array<string>();
                            const metadata_4: thrift.IThriftList = input.readListBegin();
                            const size_4: number = metadata_4.size;
                            for (let i_4: number = 0; i_4 < size_4; i_4++) {
                                const value_41: string = input.readString();
                                value_40.push(value_41);
                            }
                            input.readListEnd();
                            value_39.push(value_40);
                        }
                        input.readListEnd();
                        _args.arg = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.arg !== undefined) {
            return {
                __name: "ListToMap__Args",
                arg: _args.arg
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ListToMap__Args from input");
        }
    }
};
export class ListToMap__Args implements thrift.IStructLike, IListToMap__Args {
    public arg: Array<Array<string>>;
    public readonly __name = "ListToMap__Args";
    constructor(args: IListToMap__ArgsArgs) {
        if (args.arg != null) {
            const value_42: Array<Array<string>> = new Array<Array<string>>();
            args.arg.forEach((value_43: Array<string>): void => {
                const value_44: Array<string> = new Array<string>();
                value_43.forEach((value_45: string): void => {
                    const value_46: string = value_45;
                    value_44.push(value_46);
                });
                value_42.push(value_44);
            });
            this.arg = value_42;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ListToMap__Args {
        return new ListToMap__Args(ListToMap__ArgsCodec.decode(input));
    }
    public static write(args: IListToMap__ArgsArgs, output: thrift.TProtocol): void {
        return ListToMap__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ListToMap__ArgsCodec.encode(this, output);
    }
}
export interface IFetchThing__Args {
    __name: "FetchThing__Args";
}
export interface IFetchThing__ArgsArgs {
}
export const FetchThing__ArgsCodec: thrift.IStructCodec<IFetchThing__ArgsArgs, IFetchThing__Args> = {
    encode(args: IFetchThing__ArgsArgs, output: thrift.TProtocol): void {
        output.writeStructBegin("FetchThing__Args");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IFetchThing__Args {
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "FetchThing__Args"
        };
    }
};
export class FetchThing__Args implements thrift.IStructLike, IFetchThing__Args {
    public readonly __name = "FetchThing__Args";
    constructor(args: IFetchThing__ArgsArgs = {}) {
    }
    public static read(input: thrift.TProtocol): FetchThing__Args {
        return new FetchThing__Args(FetchThing__ArgsCodec.decode(input));
    }
    public static write(args: IFetchThing__ArgsArgs, output: thrift.TProtocol): void {
        return FetchThing__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return FetchThing__ArgsCodec.encode(this, output);
    }
}
export interface IFetchMap__Args {
    __name: "FetchMap__Args";
}
export interface IFetchMap__ArgsArgs {
}
export const FetchMap__ArgsCodec: thrift.IStructCodec<IFetchMap__ArgsArgs, IFetchMap__Args> = {
    encode(args: IFetchMap__ArgsArgs, output: thrift.TProtocol): void {
        output.writeStructBegin("FetchMap__Args");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IFetchMap__Args {
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "FetchMap__Args"
        };
    }
};
export class FetchMap__Args implements thrift.IStructLike, IFetchMap__Args {
    public readonly __name = "FetchMap__Args";
    constructor(args: IFetchMap__ArgsArgs = {}) {
    }
    public static read(input: thrift.TProtocol): FetchMap__Args {
        return new FetchMap__Args(FetchMap__ArgsCodec.decode(input));
    }
    public static write(args: IFetchMap__ArgsArgs, output: thrift.TProtocol): void {
        return FetchMap__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return FetchMap__ArgsCodec.encode(this, output);
    }
}
export interface IZip__Args {
    __name: "Zip__Args";
}
export interface IZip__ArgsArgs {
}
export const Zip__ArgsCodec: thrift.IStructCodec<IZip__ArgsArgs, IZip__Args> = {
    encode(args: IZip__ArgsArgs, output: thrift.TProtocol): void {
        output.writeStructBegin("Zip__Args");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IZip__Args {
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "Zip__Args"
        };
    }
};
export class Zip__Args implements thrift.IStructLike, IZip__Args {
    public readonly __name = "Zip__Args";
    constructor(args: IZip__ArgsArgs = {}) {
    }
    public static read(input: thrift.TProtocol): Zip__Args {
        return new Zip__Args(Zip__ArgsCodec.decode(input));
    }
    public static write(args: IZip__ArgsArgs, output: thrift.TProtocol): void {
        return Zip__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Zip__ArgsCodec.encode(this, output);
    }
}
export interface IPing__Result {
    __name: "Ping__Result";
    success?: void;
}
export interface IPing__ResultArgs {
    success?: void;
}
export const Ping__ResultCodec: thrift.IStructCodec<IPing__ResultArgs, IPing__Result> = {
    encode(args: IPing__ResultArgs, output: thrift.TProtocol): void {
        output.writeStructBegin("Ping__Result");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IPing__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.VOID) {
                        input.skip(fieldType);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "Ping__Result",
            success: _args.success
        };
    }
};
export class Ping__Result implements thrift.IStructLike, IPing__Result {
    public success?: void;
    public readonly __name = "Ping__Result";
    constructor(args: IPing__ResultArgs = {}) {
        if (args.success != null) {
            const value_47: void = undefined;
            this.success = value_47;
        }
    }
    public static read(input: thrift.TProtocol): Ping__Result {
        return new Ping__Result(Ping__ResultCodec.decode(input));
    }
    public static write(args: IPing__ResultArgs, output: thrift.TProtocol): void {
        return Ping__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Ping__ResultCodec.encode(this, output);
    }
}
export interface IAdd__Result {
    __name: "Add__Result";
    success?: number;
    exp?: com_test_operation.IJankyResult;
}
export interface IAdd__ResultArgs {
    success?: number;
    exp?: com_test_operation.IJankyResultArgs;
}
export const Add__ResultCodec: thrift.IStructCodec<IAdd__ResultArgs, IAdd__Result> = {
    encode(args: IAdd__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success,
            exp: args.exp
        };
        output.writeStructBegin("Add__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.I32, 0);
            output.writeI32(obj.success);
            output.writeFieldEnd();
        }
        if (obj.exp != null) {
            output.writeFieldBegin("exp", thrift.TType.STRUCT, 1);
            com_test_operation.JankyResultCodec.encode(obj.exp, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IAdd__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.I32) {
                        const value_48: number = input.readI32();
                        _args.success = value_48;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_49: com_test_operation.IJankyResult = com_test_operation.JankyResultCodec.decode(input);
                        _args.exp = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "Add__Result",
            success: _args.success,
            exp: _args.exp
        };
    }
};
export class Add__Result implements thrift.IStructLike, IAdd__Result {
    public success?: number;
    public exp?: com_test_operation.IJankyResult;
    public readonly __name = "Add__Result";
    constructor(args: IAdd__ResultArgs = {}) {
        if (args.success != null) {
            const value_50: number = args.success;
            this.success = value_50;
        }
        if (args.exp != null) {
            const value_51: com_test_operation.IJankyResult = new com_test_operation.JankyResult(args.exp);
            this.exp = value_51;
        }
    }
    public static read(input: thrift.TProtocol): Add__Result {
        return new Add__Result(Add__ResultCodec.decode(input));
    }
    public static write(args: IAdd__ResultArgs, output: thrift.TProtocol): void {
        return Add__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Add__ResultCodec.encode(this, output);
    }
}
export interface IAddInt64__Result {
    __name: "AddInt64__Result";
    success?: bigint;
    exp?: NotAGoodIdea.INotAGoodIdea;
}
export interface IAddInt64__ResultArgs {
    success?: number | string | bigint;
    exp?: NotAGoodIdea.INotAGoodIdeaArgs;
}
export const AddInt64__ResultCodec: thrift.IStructCodec<IAddInt64__ResultArgs, IAddInt64__Result> = {
    encode(args: IAddInt64__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: (typeof args.success === "number" ? BigInt(args.success) : typeof args.success === "string" ? BigInt(args.success) : args.success),
            exp: args.exp
        };
        output.writeStructBegin("AddInt64__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.I64, 0);
            output.writeI64((typeof obj.success === "number" ? BigInt(obj.success) : typeof obj.success === "string" ? BigInt(obj.success) : obj.success));
            output.writeFieldEnd();
        }
        if (obj.exp != null) {
            output.writeFieldBegin("exp", thrift.TType.STRUCT, 1);
            NotAGoodIdea.NotAGoodIdeaCodec.encode(obj.exp, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IAddInt64__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.I64) {
                        const value_52: bigint = input.readI64();
                        _args.success = value_52;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_53: NotAGoodIdea.INotAGoodIdea = NotAGoodIdea.NotAGoodIdeaCodec.decode(input);
                        _args.exp = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "AddInt64__Result",
            success: _args.success,
            exp: _args.exp
        };
    }
};
export class AddInt64__Result implements thrift.IStructLike, IAddInt64__Result {
    public success?: bigint;
    public exp?: NotAGoodIdea.INotAGoodIdea;
    public readonly __name = "AddInt64__Result";
    constructor(args: IAddInt64__ResultArgs = {}) {
        if (args.success != null) {
            const value_54: bigint = (typeof args.success === "number" ? BigInt(args.success) : typeof args.success === "string" ? BigInt(args.success) : args.success);
            this.success = value_54;
        }
        if (args.exp != null) {
            const value_55: NotAGoodIdea.INotAGoodIdea = new NotAGoodIdea.NotAGoodIdea(args.exp);
            this.exp = value_55;
        }
    }
    public static read(input: thrift.TProtocol): AddInt64__Result {
        return new AddInt64__Result(AddInt64__ResultCodec.decode(input));
    }
    public static write(args: IAddInt64__ResultArgs, output: thrift.TProtocol): void {
        return AddInt64__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return AddInt64__ResultCodec.encode(this, output);
    }
}
export interface IAddWithContext__Result {
    __name: "AddWithContext__Result";
    success?: number;
}
export interface IAddWithContext__ResultArgs {
    success?: number;
}
export const AddWithContext__ResultCodec: thrift.IStructCodec<IAddWithContext__ResultArgs, IAddWithContext__Result> = {
    encode(args: IAddWithContext__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success
        };
        output.writeStructBegin("AddWithContext__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.I32, 0);
            output.writeI32(obj.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IAddWithContext__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.I32) {
                        const value_56: number = input.readI32();
                        _args.success = value_56;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "AddWithContext__Result",
            success: _args.success
        };
    }
};
export class AddWithContext__Result implements thrift.IStructLike, IAddWithContext__Result {
    public success?: number;
    public readonly __name = "AddWithContext__Result";
    constructor(args: IAddWithContext__ResultArgs = {}) {
        if (args.success != null) {
            const value_57: number = args.success;
            this.success = value_57;
        }
    }
    public static read(input: thrift.TProtocol): AddWithContext__Result {
        return new AddWithContext__Result(AddWithContext__ResultCodec.decode(input));
    }
    public static write(args: IAddWithContext__ResultArgs, output: thrift.TProtocol): void {
        return AddWithContext__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return AddWithContext__ResultCodec.encode(this, output);
    }
}
export interface ICalculate__Result {
    __name: "Calculate__Result";
    success?: number;
    ouch?: com_test_operation.IJankyOperation;
}
export interface ICalculate__ResultArgs {
    success?: number;
    ouch?: com_test_operation.IJankyOperationArgs;
}
export const Calculate__ResultCodec: thrift.IStructCodec<ICalculate__ResultArgs, ICalculate__Result> = {
    encode(args: ICalculate__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success,
            ouch: args.ouch
        };
        output.writeStructBegin("Calculate__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.I32, 0);
            output.writeI32(obj.success);
            output.writeFieldEnd();
        }
        if (obj.ouch != null) {
            output.writeFieldBegin("ouch", thrift.TType.STRUCT, 1);
            com_test_operation.JankyOperationCodec.encode(obj.ouch, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICalculate__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.I32) {
                        const value_58: number = input.readI32();
                        _args.success = value_58;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_59: com_test_operation.IJankyOperation = com_test_operation.JankyOperationCodec.decode(input);
                        _args.ouch = value_59;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "Calculate__Result",
            success: _args.success,
            ouch: _args.ouch
        };
    }
};
export class Calculate__Result implements thrift.IStructLike, ICalculate__Result {
    public success?: number;
    public ouch?: com_test_operation.IJankyOperation;
    public readonly __name = "Calculate__Result";
    constructor(args: ICalculate__ResultArgs = {}) {
        if (args.success != null) {
            const value_60: number = args.success;
            this.success = value_60;
        }
        if (args.ouch != null) {
            const value_61: com_test_operation.IJankyOperation = new com_test_operation.JankyOperation(args.ouch);
            this.ouch = value_61;
        }
    }
    public static read(input: thrift.TProtocol): Calculate__Result {
        return new Calculate__Result(Calculate__ResultCodec.decode(input));
    }
    public static write(args: ICalculate__ResultArgs, output: thrift.TProtocol): void {
        return Calculate__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Calculate__ResultCodec.encode(this, output);
    }
}
export interface IEchoBinary__Result {
    __name: "EchoBinary__Result";
    success?: string;
}
export interface IEchoBinary__ResultArgs {
    success?: string;
}
export const EchoBinary__ResultCodec: thrift.IStructCodec<IEchoBinary__ResultArgs, IEchoBinary__Result> = {
    encode(args: IEchoBinary__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success
        };
        output.writeStructBegin("EchoBinary__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRING, 0);
            output.writeString(obj.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IEchoBinary__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRING) {
                        const value_62: string = input.readString();
                        _args.success = value_62;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "EchoBinary__Result",
            success: _args.success
        };
    }
};
export class EchoBinary__Result implements thrift.IStructLike, IEchoBinary__Result {
    public success?: string;
    public readonly __name = "EchoBinary__Result";
    constructor(args: IEchoBinary__ResultArgs = {}) {
        if (args.success != null) {
            const value_63: string = args.success;
            this.success = value_63;
        }
    }
    public static read(input: thrift.TProtocol): EchoBinary__Result {
        return new EchoBinary__Result(EchoBinary__ResultCodec.decode(input));
    }
    public static write(args: IEchoBinary__ResultArgs, output: thrift.TProtocol): void {
        return EchoBinary__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return EchoBinary__ResultCodec.encode(this, output);
    }
}
export interface IEchoString__Result {
    __name: "EchoString__Result";
    success?: string;
}
export interface IEchoString__ResultArgs {
    success?: string;
}
export const EchoString__ResultCodec: thrift.IStructCodec<IEchoString__ResultArgs, IEchoString__Result> = {
    encode(args: IEchoString__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success
        };
        output.writeStructBegin("EchoString__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRING, 0);
            output.writeString(obj.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IEchoString__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRING) {
                        const value_64: string = input.readString();
                        _args.success = value_64;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "EchoString__Result",
            success: _args.success
        };
    }
};
export class EchoString__Result implements thrift.IStructLike, IEchoString__Result {
    public success?: string;
    public readonly __name = "EchoString__Result";
    constructor(args: IEchoString__ResultArgs = {}) {
        if (args.success != null) {
            const value_65: string = args.success;
            this.success = value_65;
        }
    }
    public static read(input: thrift.TProtocol): EchoString__Result {
        return new EchoString__Result(EchoString__ResultCodec.decode(input));
    }
    public static write(args: IEchoString__ResultArgs, output: thrift.TProtocol): void {
        return EchoString__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return EchoString__ResultCodec.encode(this, output);
    }
}
export interface ICheckName__Result {
    __name: "CheckName__Result";
    success?: string;
}
export interface ICheckName__ResultArgs {
    success?: string;
}
export const CheckName__ResultCodec: thrift.IStructCodec<ICheckName__ResultArgs, ICheckName__Result> = {
    encode(args: ICheckName__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success
        };
        output.writeStructBegin("CheckName__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRING, 0);
            output.writeString(obj.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICheckName__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRING) {
                        const value_66: string = input.readString();
                        _args.success = value_66;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "CheckName__Result",
            success: _args.success
        };
    }
};
export class CheckName__Result implements thrift.IStructLike, ICheckName__Result {
    public success?: string;
    public readonly __name = "CheckName__Result";
    constructor(args: ICheckName__ResultArgs = {}) {
        if (args.success != null) {
            const value_67: string = args.success;
            this.success = value_67;
        }
    }
    public static read(input: thrift.TProtocol): CheckName__Result {
        return new CheckName__Result(CheckName__ResultCodec.decode(input));
    }
    public static write(args: ICheckName__ResultArgs, output: thrift.TProtocol): void {
        return CheckName__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CheckName__ResultCodec.encode(this, output);
    }
}
export interface ICheckOptional__Result {
    __name: "CheckOptional__Result";
    success?: string;
}
export interface ICheckOptional__ResultArgs {
    success?: string;
}
export const CheckOptional__ResultCodec: thrift.IStructCodec<ICheckOptional__ResultArgs, ICheckOptional__Result> = {
    encode(args: ICheckOptional__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success
        };
        output.writeStructBegin("CheckOptional__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRING, 0);
            output.writeString(obj.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICheckOptional__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRING) {
                        const value_68: string = input.readString();
                        _args.success = value_68;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "CheckOptional__Result",
            success: _args.success
        };
    }
};
export class CheckOptional__Result implements thrift.IStructLike, ICheckOptional__Result {
    public success?: string;
    public readonly __name = "CheckOptional__Result";
    constructor(args: ICheckOptional__ResultArgs = {}) {
        if (args.success != null) {
            const value_69: string = args.success;
            this.success = value_69;
        }
    }
    public static read(input: thrift.TProtocol): CheckOptional__Result {
        return new CheckOptional__Result(CheckOptional__ResultCodec.decode(input));
    }
    public static write(args: ICheckOptional__ResultArgs, output: thrift.TProtocol): void {
        return CheckOptional__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CheckOptional__ResultCodec.encode(this, output);
    }
}
export interface IMapOneList__Result {
    __name: "MapOneList__Result";
    success?: Array<number>;
}
export interface IMapOneList__ResultArgs {
    success?: Array<number>;
}
export const MapOneList__ResultCodec: thrift.IStructCodec<IMapOneList__ResultArgs, IMapOneList__Result> = {
    encode(args: IMapOneList__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success
        };
        output.writeStructBegin("MapOneList__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.LIST, 0);
            output.writeListBegin(thrift.TType.I32, obj.success.length);
            obj.success.forEach((value_70: number): void => {
                output.writeI32(value_70);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IMapOneList__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.LIST) {
                        const value_71: Array<number> = new Array<number>();
                        const metadata_5: thrift.IThriftList = input.readListBegin();
                        const size_5: number = metadata_5.size;
                        for (let i_5: number = 0; i_5 < size_5; i_5++) {
                            const value_72: number = input.readI32();
                            value_71.push(value_72);
                        }
                        input.readListEnd();
                        _args.success = value_71;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "MapOneList__Result",
            success: _args.success
        };
    }
};
export class MapOneList__Result implements thrift.IStructLike, IMapOneList__Result {
    public success?: Array<number>;
    public readonly __name = "MapOneList__Result";
    constructor(args: IMapOneList__ResultArgs = {}) {
        if (args.success != null) {
            const value_73: Array<number> = new Array<number>();
            args.success.forEach((value_74: number): void => {
                const value_75: number = value_74;
                value_73.push(value_75);
            });
            this.success = value_73;
        }
    }
    public static read(input: thrift.TProtocol): MapOneList__Result {
        return new MapOneList__Result(MapOneList__ResultCodec.decode(input));
    }
    public static write(args: IMapOneList__ResultArgs, output: thrift.TProtocol): void {
        return MapOneList__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return MapOneList__ResultCodec.encode(this, output);
    }
}
export interface IMapValues__Result {
    __name: "MapValues__Result";
    success?: Array<number>;
}
export interface IMapValues__ResultArgs {
    success?: Array<number>;
}
export const MapValues__ResultCodec: thrift.IStructCodec<IMapValues__ResultArgs, IMapValues__Result> = {
    encode(args: IMapValues__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success
        };
        output.writeStructBegin("MapValues__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.LIST, 0);
            output.writeListBegin(thrift.TType.I32, obj.success.length);
            obj.success.forEach((value_76: number): void => {
                output.writeI32(value_76);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IMapValues__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.LIST) {
                        const value_77: Array<number> = new Array<number>();
                        const metadata_6: thrift.IThriftList = input.readListBegin();
                        const size_6: number = metadata_6.size;
                        for (let i_6: number = 0; i_6 < size_6; i_6++) {
                            const value_78: number = input.readI32();
                            value_77.push(value_78);
                        }
                        input.readListEnd();
                        _args.success = value_77;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "MapValues__Result",
            success: _args.success
        };
    }
};
export class MapValues__Result implements thrift.IStructLike, IMapValues__Result {
    public success?: Array<number>;
    public readonly __name = "MapValues__Result";
    constructor(args: IMapValues__ResultArgs = {}) {
        if (args.success != null) {
            const value_79: Array<number> = new Array<number>();
            args.success.forEach((value_80: number): void => {
                const value_81: number = value_80;
                value_79.push(value_81);
            });
            this.success = value_79;
        }
    }
    public static read(input: thrift.TProtocol): MapValues__Result {
        return new MapValues__Result(MapValues__ResultCodec.decode(input));
    }
    public static write(args: IMapValues__ResultArgs, output: thrift.TProtocol): void {
        return MapValues__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return MapValues__ResultCodec.encode(this, output);
    }
}
export interface IListToMap__Result {
    __name: "ListToMap__Result";
    success?: Map<string, string>;
}
export interface IListToMap__ResultArgs {
    success?: Map<string, string>;
}
export const ListToMap__ResultCodec: thrift.IStructCodec<IListToMap__ResultArgs, IListToMap__Result> = {
    encode(args: IListToMap__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success
        };
        output.writeStructBegin("ListToMap__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.MAP, 0);
            output.writeMapBegin(thrift.TType.STRING, thrift.TType.STRING, obj.success.size);
            obj.success.forEach((value_82: string, key_5: string): void => {
                output.writeString(key_5);
                output.writeString(value_82);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IListToMap__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.MAP) {
                        const value_83: Map<string, string> = new Map<string, string>();
                        const metadata_7: thrift.IThriftMap = input.readMapBegin();
                        const size_7: number = metadata_7.size;
                        for (let i_7: number = 0; i_7 < size_7; i_7++) {
                            const key_6: string = input.readString();
                            const value_84: string = input.readString();
                            value_83.set(key_6, value_84);
                        }
                        input.readMapEnd();
                        _args.success = value_83;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "ListToMap__Result",
            success: _args.success
        };
    }
};
export class ListToMap__Result implements thrift.IStructLike, IListToMap__Result {
    public success?: Map<string, string>;
    public readonly __name = "ListToMap__Result";
    constructor(args: IListToMap__ResultArgs = {}) {
        if (args.success != null) {
            const value_85: Map<string, string> = new Map<string, string>();
            args.success.forEach((value_86: string, key_7: string): void => {
                const value_87: string = value_86;
                const key_8: string = key_7;
                value_85.set(key_8, value_87);
            });
            this.success = value_85;
        }
    }
    public static read(input: thrift.TProtocol): ListToMap__Result {
        return new ListToMap__Result(ListToMap__ResultCodec.decode(input));
    }
    public static write(args: IListToMap__ResultArgs, output: thrift.TProtocol): void {
        return ListToMap__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ListToMap__ResultCodec.encode(this, output);
    }
}
export interface IFetchThing__Result {
    __name: "FetchThing__Result";
    success?: com_test_common.ICommonStruct;
}
export interface IFetchThing__ResultArgs {
    success?: com_test_common.ICommonStructArgs;
}
export const FetchThing__ResultCodec: thrift.IStructCodec<IFetchThing__ResultArgs, IFetchThing__Result> = {
    encode(args: IFetchThing__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success
        };
        output.writeStructBegin("FetchThing__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            com_test_common.CommonStructCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IFetchThing__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_88: com_test_common.ICommonStruct = com_test_common.CommonStructCodec.decode(input);
                        _args.success = value_88;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "FetchThing__Result",
            success: _args.success
        };
    }
};
export class FetchThing__Result implements thrift.IStructLike, IFetchThing__Result {
    public success?: com_test_common.ICommonStruct;
    public readonly __name = "FetchThing__Result";
    constructor(args: IFetchThing__ResultArgs = {}) {
        if (args.success != null) {
            const value_89: com_test_common.ICommonStruct = new com_test_common.CommonStruct(args.success);
            this.success = value_89;
        }
    }
    public static read(input: thrift.TProtocol): FetchThing__Result {
        return new FetchThing__Result(FetchThing__ResultCodec.decode(input));
    }
    public static write(args: IFetchThing__ResultArgs, output: thrift.TProtocol): void {
        return FetchThing__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return FetchThing__ResultCodec.encode(this, output);
    }
}
export interface IFetchMap__Result {
    __name: "FetchMap__Result";
    success?: TypedMap.TypedMap;
}
export interface IFetchMap__ResultArgs {
    success?: TypedMap.TypedMap;
}
export const FetchMap__ResultCodec: thrift.IStructCodec<IFetchMap__ResultArgs, IFetchMap__Result> = {
    encode(args: IFetchMap__ResultArgs, output: thrift.TProtocol): void {
        const obj = {
            success: args.success
        };
        output.writeStructBegin("FetchMap__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.MAP, 0);
            output.writeMapBegin(thrift.TType.STRING, thrift.TType.STRUCT, obj.success.size);
            obj.success.forEach((value_90: CommonStruct.ICommonStructArgs, key_9: string): void => {
                output.writeString(key_9);
                CommonStruct.CommonStructCodec.encode(value_90, output);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IFetchMap__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.MAP) {
                        const value_91: Map<string, CommonStruct.ICommonStruct> = new Map<string, CommonStruct.ICommonStruct>();
                        const metadata_8: thrift.IThriftMap = input.readMapBegin();
                        const size_8: number = metadata_8.size;
                        for (let i_8: number = 0; i_8 < size_8; i_8++) {
                            const key_10: string = input.readString();
                            const value_92: CommonStruct.ICommonStruct = CommonStruct.CommonStructCodec.decode(input);
                            value_91.set(key_10, value_92);
                        }
                        input.readMapEnd();
                        _args.success = value_91;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "FetchMap__Result",
            success: _args.success
        };
    }
};
export class FetchMap__Result implements thrift.IStructLike, IFetchMap__Result {
    public success?: TypedMap.TypedMap;
    public readonly __name = "FetchMap__Result";
    constructor(args: IFetchMap__ResultArgs = {}) {
        if (args.success != null) {
            const value_93: Map<string, CommonStruct.ICommonStruct> = new Map<string, CommonStruct.ICommonStruct>();
            args.success.forEach((value_94: CommonStruct.ICommonStructArgs, key_11: string): void => {
                const value_95: CommonStruct.ICommonStruct = new CommonStruct.CommonStruct(value_94);
                const key_12: string = key_11;
                value_93.set(key_12, value_95);
            });
            this.success = value_93;
        }
    }
    public static read(input: thrift.TProtocol): FetchMap__Result {
        return new FetchMap__Result(FetchMap__ResultCodec.decode(input));
    }
    public static write(args: IFetchMap__ResultArgs, output: thrift.TProtocol): void {
        return FetchMap__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return FetchMap__ResultCodec.encode(this, output);
    }
}
export interface IZip__Result {
    __name: "Zip__Result";
    success?: void;
}
export interface IZip__ResultArgs {
    success?: void;
}
export const Zip__ResultCodec: thrift.IStructCodec<IZip__ResultArgs, IZip__Result> = {
    encode(args: IZip__ResultArgs, output: thrift.TProtocol): void {
        output.writeStructBegin("Zip__Result");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IZip__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.VOID) {
                        input.skip(fieldType);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            __name: "Zip__Result",
            success: _args.success
        };
    }
};
export class Zip__Result implements thrift.IStructLike, IZip__Result {
    public success?: void;
    public readonly __name = "Zip__Result";
    constructor(args: IZip__ResultArgs = {}) {
        if (args.success != null) {
            const value_96: void = undefined;
            this.success = value_96;
        }
    }
    public static read(input: thrift.TProtocol): Zip__Result {
        return new Zip__Result(Zip__ResultCodec.decode(input));
    }
    public static write(args: IZip__ResultArgs, output: thrift.TProtocol): void {
        return Zip__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Zip__ResultCodec.encode(this, output);
    }
}
export class Client<Context extends thrift.IRequestContext = thrift.IRequestContext> extends __ROOT_NAMESPACE__.SharedService.Client<Context> {
    public static readonly metadata: thrift.IServiceMetadata = metadata;
    public readonly __metadata: thrift.IServiceMetadata = metadata;
    constructor(connection: thrift.IThriftConnection<Context>) {
        super(connection);
    }
    protected incrementRequestId(): number {
        return this._requestId += 1;
    }
    public ping(context?: Context): Promise<void> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ping", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IPing__ArgsArgs = {};
        Ping__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ping") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IPing__Result = Ping__ResultCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.resolve(result.success);
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public add(num1: number, num2: number, context?: Context): Promise<number> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("add", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IAdd__ArgsArgs = { num1, num2 };
        Add__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "add") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IAdd__Result = Add__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.exp != null) {
                            return Promise.reject(result.exp);
                        }
                        else if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "add failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public addInt64(num1: number | string | bigint, num2: number | string | bigint, context?: Context): Promise<bigint> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("addInt64", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IAddInt64__ArgsArgs = { num1, num2 };
        AddInt64__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "addInt64") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IAddInt64__Result = AddInt64__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.exp != null) {
                            return Promise.reject(result.exp);
                        }
                        else if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "addInt64 failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public addWithContext(num1: number, num2: number, context?: Context): Promise<number> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("addWithContext", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IAddWithContext__ArgsArgs = { num1, num2 };
        AddWithContext__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "addWithContext") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IAddWithContext__Result = AddWithContext__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "addWithContext failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public calculate(logid: number, work: Work.IWorkArgs, context?: Context): Promise<number> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("calculate", thrift.MessageType.CALL, this.incrementRequestId());
        const args: ICalculate__ArgsArgs = { logid, work };
        Calculate__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "calculate") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ICalculate__Result = Calculate__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.ouch != null) {
                            return Promise.reject(result.ouch);
                        }
                        else if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "calculate failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public echoBinary(word: string | Buffer, context?: Context): Promise<string> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("echoBinary", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IEchoBinary__ArgsArgs = { word };
        EchoBinary__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "echoBinary") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IEchoBinary__Result = EchoBinary__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "echoBinary failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public echoString(word: string, context?: Context): Promise<string> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("echoString", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IEchoString__ArgsArgs = { word };
        EchoString__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "echoString") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IEchoString__Result = EchoString__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "echoString failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public checkName(choice: Choice.ChoiceArgs, context?: Context): Promise<string> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("checkName", thrift.MessageType.CALL, this.incrementRequestId());
        const args: ICheckName__ArgsArgs = { choice };
        CheckName__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "checkName") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ICheckName__Result = CheckName__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "checkName failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public checkOptional(type?: string, context?: Context): Promise<string> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("checkOptional", thrift.MessageType.CALL, this.incrementRequestId());
        const args: ICheckOptional__ArgsArgs = { type };
        CheckOptional__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "checkOptional") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ICheckOptional__Result = CheckOptional__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "checkOptional failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public mapOneList(arg: Array<number>, context?: Context): Promise<Array<number>> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("mapOneList", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IMapOneList__ArgsArgs = { arg };
        MapOneList__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "mapOneList") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IMapOneList__Result = MapOneList__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "mapOneList failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public mapValues(arg: Map<string, number>, context?: Context): Promise<Array<number>> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("mapValues", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IMapValues__ArgsArgs = { arg };
        MapValues__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "mapValues") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IMapValues__Result = MapValues__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "mapValues failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public listToMap(arg: Array<Array<string>>, context?: Context): Promise<Map<string, string>> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("listToMap", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IListToMap__ArgsArgs = { arg };
        ListToMap__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "listToMap") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IListToMap__Result = ListToMap__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "listToMap failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public fetchThing(context?: Context): Promise<com_test_common.ICommonStruct> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("fetchThing", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IFetchThing__ArgsArgs = {};
        FetchThing__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "fetchThing") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IFetchThing__Result = FetchThing__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "fetchThing failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public fetchMap(context?: Context): Promise<TypedMap.TypedMap> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("fetchMap", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IFetchMap__ArgsArgs = {};
        FetchMap__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "fetchMap") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IFetchMap__Result = FetchMap__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "fetchMap failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public zip(context?: Context): Promise<void> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("zip", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IZip__ArgsArgs = {};
        Zip__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.Transport.receiver(data);
            const input: thrift.TProtocol = new this.Protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "zip") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IZip__Result = Zip__ResultCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.resolve(result.success);
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
}
export interface ILocalHandler<Context extends object = {}> {
    ping(context: thrift.ThriftContext<Context>): void | Promise<void>;
    add(num1: number, num2: number, context: thrift.ThriftContext<Context>): number | Promise<number>;
    addInt64(num1: bigint, num2: bigint, context: thrift.ThriftContext<Context>): (number | string | bigint) | Promise<number | string | bigint>;
    addWithContext(num1: number, num2: number, context: thrift.ThriftContext<Context>): number | Promise<number>;
    calculate(logid: number, work: Work.IWork, context: thrift.ThriftContext<Context>): number | Promise<number>;
    echoBinary(word: Buffer, context: thrift.ThriftContext<Context>): string | Promise<string>;
    echoString(word: string, context: thrift.ThriftContext<Context>): string | Promise<string>;
    checkName(choice: Choice.Choice, context: thrift.ThriftContext<Context>): string | Promise<string>;
    checkOptional(type: string | undefined, context: thrift.ThriftContext<Context>): string | Promise<string>;
    mapOneList(arg: Array<number>, context: thrift.ThriftContext<Context>): Array<number> | Promise<Array<number>>;
    mapValues(arg: Map<string, number>, context: thrift.ThriftContext<Context>): Array<number> | Promise<Array<number>>;
    listToMap(arg: Array<Array<string>>, context: thrift.ThriftContext<Context>): Map<string, string> | Promise<Map<string, string>>;
    fetchThing(context: thrift.ThriftContext<Context>): com_test_common.ICommonStructArgs | Promise<com_test_common.ICommonStructArgs>;
    fetchMap(context: thrift.ThriftContext<Context>): TypedMap.TypedMap | Promise<TypedMap.TypedMap>;
    zip(context: thrift.ThriftContext<Context>): void | Promise<void>;
}
export type IHandler<Context extends object = {}> = ILocalHandler<Context> & __ROOT_NAMESPACE__.SharedService.IHandler<Context>;
export type ReadRequestData = {
    methodName: "ping";
    requestId: number;
    data: IPing__Args;
} | {
    methodName: "add";
    requestId: number;
    data: IAdd__Args;
} | {
    methodName: "addInt64";
    requestId: number;
    data: IAddInt64__Args;
} | {
    methodName: "addWithContext";
    requestId: number;
    data: IAddWithContext__Args;
} | {
    methodName: "calculate";
    requestId: number;
    data: ICalculate__Args;
} | {
    methodName: "echoBinary";
    requestId: number;
    data: IEchoBinary__Args;
} | {
    methodName: "echoString";
    requestId: number;
    data: IEchoString__Args;
} | {
    methodName: "checkName";
    requestId: number;
    data: ICheckName__Args;
} | {
    methodName: "checkOptional";
    requestId: number;
    data: ICheckOptional__Args;
} | {
    methodName: "mapOneList";
    requestId: number;
    data: IMapOneList__Args;
} | {
    methodName: "mapValues";
    requestId: number;
    data: IMapValues__Args;
} | {
    methodName: "listToMap";
    requestId: number;
    data: IListToMap__Args;
} | {
    methodName: "fetchThing";
    requestId: number;
    data: IFetchThing__Args;
} | {
    methodName: "fetchMap";
    requestId: number;
    data: IFetchMap__Args;
} | {
    methodName: "zip";
    requestId: number;
    data: IZip__Args;
} | __ROOT_NAMESPACE__.SharedService.ReadRequestData;
export class Processor<Context extends object = {}> implements thrift.IThriftProcessor<Context> {
    protected readonly parent: __ROOT_NAMESPACE__.SharedService.Processor<Context>;
    protected readonly handler: IHandler<Context>;
    public static readonly metadata: thrift.IServiceMetadata = metadata;
    public readonly __metadata: thrift.IServiceMetadata = metadata;
    public readonly Transport: thrift.ITransportConstructor;
    public readonly Protocol: thrift.IProtocolConstructor;
    constructor(handler: IHandler<Context>, Transport: thrift.ITransportConstructor = thrift.BufferedTransport, Protocol: thrift.IProtocolConstructor = thrift.BinaryProtocol) {
        this.parent = new __ROOT_NAMESPACE__.SharedService.Processor<Context>({
            getUnion: handler.getUnion,
            getEnum: handler.getEnum,
            getStruct: handler.getStruct
        }, transport, protocol);
        this.handler = handler;
        this.Transport = Transport;
        this.Protocol = Protocol;
    }
    public process(data: Buffer, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<Buffer>((resolve, reject): void => {
            const metadata: ReadRequestData = this.readRequest(data);
            switch (metadata.methodName) {
                case "ping": {
                    resolve(this.process_ping(metadata.data, metadata.requestId, context));
                    break;
                }
                case "add": {
                    resolve(this.process_add(metadata.data, metadata.requestId, context));
                    break;
                }
                case "addInt64": {
                    resolve(this.process_addInt64(metadata.data, metadata.requestId, context));
                    break;
                }
                case "addWithContext": {
                    resolve(this.process_addWithContext(metadata.data, metadata.requestId, context));
                    break;
                }
                case "calculate": {
                    resolve(this.process_calculate(metadata.data, metadata.requestId, context));
                    break;
                }
                case "echoBinary": {
                    resolve(this.process_echoBinary(metadata.data, metadata.requestId, context));
                    break;
                }
                case "echoString": {
                    resolve(this.process_echoString(metadata.data, metadata.requestId, context));
                    break;
                }
                case "checkName": {
                    resolve(this.process_checkName(metadata.data, metadata.requestId, context));
                    break;
                }
                case "checkOptional": {
                    resolve(this.process_checkOptional(metadata.data, metadata.requestId, context));
                    break;
                }
                case "mapOneList": {
                    resolve(this.process_mapOneList(metadata.data, metadata.requestId, context));
                    break;
                }
                case "mapValues": {
                    resolve(this.process_mapValues(metadata.data, metadata.requestId, context));
                    break;
                }
                case "listToMap": {
                    resolve(this.process_listToMap(metadata.data, metadata.requestId, context));
                    break;
                }
                case "fetchThing": {
                    resolve(this.process_fetchThing(metadata.data, metadata.requestId, context));
                    break;
                }
                case "fetchMap": {
                    resolve(this.process_fetchMap(metadata.data, metadata.requestId, context));
                    break;
                }
                case "zip": {
                    resolve(this.process_zip(metadata.data, metadata.requestId, context));
                    break;
                }
                default: {
                    resolve(this.parent.process(data, context));
                    break;
                }
            }
        });
    }
    public readRequest(data: Buffer): ReadRequestData {
        const transportWithData: thrift.TTransport = this.Transport.receiver(data);
        const input: thrift.TProtocol = new this.Protocol(transportWithData);
        const metadata: thrift.IThriftMessage = input.readMessageBegin();
        const fieldName: string = metadata.fieldName;
        const requestId: number = metadata.requestId;
        switch (fieldName) {
            case "ping": {
                const data: IPing__Args = Ping__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "add": {
                const data: IAdd__Args = Add__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "addInt64": {
                const data: IAddInt64__Args = AddInt64__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "addWithContext": {
                const data: IAddWithContext__Args = AddWithContext__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "calculate": {
                const data: ICalculate__Args = Calculate__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "echoBinary": {
                const data: IEchoBinary__Args = EchoBinary__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "echoString": {
                const data: IEchoString__Args = EchoString__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "checkName": {
                const data: ICheckName__Args = CheckName__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "checkOptional": {
                const data: ICheckOptional__Args = CheckOptional__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "mapOneList": {
                const data: IMapOneList__Args = MapOneList__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "mapValues": {
                const data: IMapValues__Args = MapValues__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "listToMap": {
                const data: IListToMap__Args = ListToMap__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "fetchThing": {
                const data: IFetchThing__Args = FetchThing__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "fetchMap": {
                const data: IFetchMap__Args = FetchMap__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            case "zip": {
                const data: IZip__Args = Zip__ArgsCodec.decode(input);
                input.readMessageEnd();
                return {
                    methodName: fieldName,
                    requestId: requestId,
                    data: data
                };
            }
            default: {
                return this.parent.readRequest(data);
            }
        }
    }
    public writeResponse(methodName: string, data: any, requestId: number): Buffer {
        const output: thrift.TProtocol = new this.Protocol(new this.Transport());
        switch (methodName) {
            case "ping": {
                const result: IPing__ResultArgs = { success: data };
                output.writeMessageBegin("ping", thrift.MessageType.REPLY, requestId);
                Ping__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "add": {
                const result: IAdd__ResultArgs = { success: data };
                output.writeMessageBegin("add", thrift.MessageType.REPLY, requestId);
                Add__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "addInt64": {
                const result: IAddInt64__ResultArgs = { success: data };
                output.writeMessageBegin("addInt64", thrift.MessageType.REPLY, requestId);
                AddInt64__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "addWithContext": {
                const result: IAddWithContext__ResultArgs = { success: data };
                output.writeMessageBegin("addWithContext", thrift.MessageType.REPLY, requestId);
                AddWithContext__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "calculate": {
                const result: ICalculate__ResultArgs = { success: data };
                output.writeMessageBegin("calculate", thrift.MessageType.REPLY, requestId);
                Calculate__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "echoBinary": {
                const result: IEchoBinary__ResultArgs = { success: data };
                output.writeMessageBegin("echoBinary", thrift.MessageType.REPLY, requestId);
                EchoBinary__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "echoString": {
                const result: IEchoString__ResultArgs = { success: data };
                output.writeMessageBegin("echoString", thrift.MessageType.REPLY, requestId);
                EchoString__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "checkName": {
                const result: ICheckName__ResultArgs = { success: data };
                output.writeMessageBegin("checkName", thrift.MessageType.REPLY, requestId);
                CheckName__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "checkOptional": {
                const result: ICheckOptional__ResultArgs = { success: data };
                output.writeMessageBegin("checkOptional", thrift.MessageType.REPLY, requestId);
                CheckOptional__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "mapOneList": {
                const result: IMapOneList__ResultArgs = { success: data };
                output.writeMessageBegin("mapOneList", thrift.MessageType.REPLY, requestId);
                MapOneList__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "mapValues": {
                const result: IMapValues__ResultArgs = { success: data };
                output.writeMessageBegin("mapValues", thrift.MessageType.REPLY, requestId);
                MapValues__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "listToMap": {
                const result: IListToMap__ResultArgs = { success: data };
                output.writeMessageBegin("listToMap", thrift.MessageType.REPLY, requestId);
                ListToMap__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "fetchThing": {
                const result: IFetchThing__ResultArgs = { success: data };
                output.writeMessageBegin("fetchThing", thrift.MessageType.REPLY, requestId);
                FetchThing__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "fetchMap": {
                const result: IFetchMap__ResultArgs = { success: data };
                output.writeMessageBegin("fetchMap", thrift.MessageType.REPLY, requestId);
                FetchMap__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            case "zip": {
                const result: IZip__ResultArgs = { success: data };
                output.writeMessageBegin("zip", thrift.MessageType.REPLY, requestId);
                Zip__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            default: {
                return this.parent.writeResponse(methodName, data, requestId);
            }
        }
    }
    public writeError(methodName: string, requestId: number, err: Error): Buffer {
        const output: thrift.TProtocol = new this.Protocol(new this.Transport());
        const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
        output.writeMessageBegin(methodName, thrift.MessageType.EXCEPTION, requestId);
        thrift.TApplicationExceptionCodec.encode(result, output);
        output.writeMessageEnd();
        return output.flush();
    }
    private process_ping(args: IPing__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<void>((resolve, reject): void => {
            try {
                resolve(this.handler.ping(context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: void): Buffer => {
            return this.writeResponse("ping", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("ping", requestId, err);
        });
    }
    private process_add(args: IAdd__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<number>((resolve, reject): void => {
            try {
                resolve(this.handler.add(args.num1, args.num2, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): Buffer => {
            return this.writeResponse("add", data, requestId);
        }).catch((err: Error): Buffer => {
            if (err instanceof com_test_operation.JankyResult) {
                const output: thrift.TProtocol = new this.Protocol(new this.Transport());
                const result: IAdd__ResultArgs = { exp: err };
                output.writeMessageBegin("add", thrift.MessageType.REPLY, requestId);
                Add__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            else {
                return this.writeError("add", requestId, err);
            }
        });
    }
    private process_addInt64(args: IAddInt64__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<number | string | bigint>((resolve, reject): void => {
            try {
                resolve(this.handler.addInt64(args.num1, args.num2, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number | string | bigint): Buffer => {
            return this.writeResponse("addInt64", data, requestId);
        }).catch((err: Error): Buffer => {
            if (err instanceof NotAGoodIdea.NotAGoodIdea) {
                const output: thrift.TProtocol = new this.Protocol(new this.Transport());
                const result: IAddInt64__ResultArgs = { exp: err };
                output.writeMessageBegin("addInt64", thrift.MessageType.REPLY, requestId);
                AddInt64__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            else {
                return this.writeError("addInt64", requestId, err);
            }
        });
    }
    private process_addWithContext(args: IAddWithContext__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<number>((resolve, reject): void => {
            try {
                resolve(this.handler.addWithContext(args.num1, args.num2, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): Buffer => {
            return this.writeResponse("addWithContext", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("addWithContext", requestId, err);
        });
    }
    private process_calculate(args: ICalculate__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<number>((resolve, reject): void => {
            try {
                resolve(this.handler.calculate(args.logid, args.work, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): Buffer => {
            return this.writeResponse("calculate", data, requestId);
        }).catch((err: Error): Buffer => {
            if (err instanceof com_test_operation.JankyOperation) {
                const output: thrift.TProtocol = new this.Protocol(new this.Transport());
                const result: ICalculate__ResultArgs = { ouch: err };
                output.writeMessageBegin("calculate", thrift.MessageType.REPLY, requestId);
                Calculate__ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }
            else {
                return this.writeError("calculate", requestId, err);
            }
        });
    }
    private process_echoBinary(args: IEchoBinary__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<string>((resolve, reject): void => {
            try {
                resolve(this.handler.echoBinary(args.word, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): Buffer => {
            return this.writeResponse("echoBinary", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("echoBinary", requestId, err);
        });
    }
    private process_echoString(args: IEchoString__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<string>((resolve, reject): void => {
            try {
                resolve(this.handler.echoString(args.word, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): Buffer => {
            return this.writeResponse("echoString", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("echoString", requestId, err);
        });
    }
    private process_checkName(args: ICheckName__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<string>((resolve, reject): void => {
            try {
                resolve(this.handler.checkName(args.choice, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): Buffer => {
            return this.writeResponse("checkName", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("checkName", requestId, err);
        });
    }
    private process_checkOptional(args: ICheckOptional__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<string>((resolve, reject): void => {
            try {
                resolve(this.handler.checkOptional(args.type, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): Buffer => {
            return this.writeResponse("checkOptional", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("checkOptional", requestId, err);
        });
    }
    private process_mapOneList(args: IMapOneList__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<Array<number>>((resolve, reject): void => {
            try {
                resolve(this.handler.mapOneList(args.arg, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<number>): Buffer => {
            return this.writeResponse("mapOneList", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("mapOneList", requestId, err);
        });
    }
    private process_mapValues(args: IMapValues__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<Array<number>>((resolve, reject): void => {
            try {
                resolve(this.handler.mapValues(args.arg, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<number>): Buffer => {
            return this.writeResponse("mapValues", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("mapValues", requestId, err);
        });
    }
    private process_listToMap(args: IListToMap__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<Map<string, string>>((resolve, reject): void => {
            try {
                resolve(this.handler.listToMap(args.arg, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<string, string>): Buffer => {
            return this.writeResponse("listToMap", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("listToMap", requestId, err);
        });
    }
    private process_fetchThing(args: IFetchThing__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<com_test_common.ICommonStructArgs>((resolve, reject): void => {
            try {
                resolve(this.handler.fetchThing(context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: com_test_common.ICommonStructArgs): Buffer => {
            return this.writeResponse("fetchThing", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("fetchThing", requestId, err);
        });
    }
    private process_fetchMap(args: IFetchMap__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<TypedMap.TypedMap>((resolve, reject): void => {
            try {
                resolve(this.handler.fetchMap(context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TypedMap.TypedMap): Buffer => {
            return this.writeResponse("fetchMap", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("fetchMap", requestId, err);
        });
    }
    private process_zip(args: IZip__Args, requestId: number, context: thrift.ThriftContext<Context>): Promise<Buffer> {
        return new Promise<void>((resolve, reject): void => {
            try {
                resolve(this.handler.zip(context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: void): Buffer => {
            return this.writeResponse("zip", data, requestId);
        }).catch((err: Error): Buffer => {
            return this.writeError("zip", requestId, err);
        });
    }
}
