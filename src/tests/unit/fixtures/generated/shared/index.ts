/* tslint:disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v2.0.0-11
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "@creditkarma/thrift-server-core";
export const SHARED_INT: number = 45;
export interface ICode {
    status?: thrift.Int64;
}
export interface ICode_Loose {
    status?: number | thrift.Int64;
}
export const CodeCodec: thrift.IStructCodec<ICode_Loose, ICode> = {
    encode(args: ICode_Loose, output: thrift.TProtocol): void {
        const obj = {
            status: (typeof args.status === "number" ? new thrift.Int64(args.status) : args.status)
        };
        output.writeStructBegin("Code");
        if (obj.status != null) {
            output.writeFieldBegin("status", thrift.TType.I64, 1);
            output.writeI64(obj.status);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICode {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.I64) {
                        const value_1: thrift.Int64 = input.readI64();
                        _args.status = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            status: _args.status
        };
    }
};
export class Code extends thrift.StructLike  implements ICode {
    public status?: thrift.Int64;
    constructor(args: ICode_Loose = {}) {
        super();
        if (args.status != null) {
            const value_2: thrift.Int64 = (typeof args.status === "number" ? new thrift.Int64(args.status) : args.status);
            this.status = value_2;
        }
    }
    public static read(input: thrift.TProtocol): Code {
        return new Code(CodeCodec.decode(input));
    }
    public write(output: thrift.TProtocol): void {
        return CodeCodec.encode(this, output);
    }
}
export interface ISharedStruct {
    code: ICode;
    value: string;
}
export interface ISharedStruct_Loose {
    code: ICode_Loose;
    value: string;
}
export const SharedStructCodec: thrift.IStructCodec<ISharedStruct_Loose, ISharedStruct> = {
    encode(args: ISharedStruct_Loose, output: thrift.TProtocol): void {
        const obj = {
            code: args.code,
            value: args.value
        };
        output.writeStructBegin("SharedStruct");
        if (obj.code != null) {
            output.writeFieldBegin("code", thrift.TType.STRUCT, 1);
            CodeCodec.encode(obj.code, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[code] is unset!");
        }
        if (obj.value != null) {
            output.writeFieldBegin("value", thrift.TType.STRING, 2);
            output.writeString(obj.value);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[value] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ISharedStruct {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_3: ICode = CodeCodec.decode(input);
                        _args.code = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.TType.STRING) {
                        const value_4: string = input.readString();
                        _args.value = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.code !== undefined && _args.value !== undefined) {
            return {
                code: _args.code,
                value: _args.value
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SharedStruct from input");
        }
    }
};
export class SharedStruct extends thrift.StructLike  implements ISharedStruct {
    public code: ICode;
    public value: string;
    constructor(args: ISharedStruct_Loose) {
        super();
        if (args.code != null) {
            const value_5: ICode = new Code(args.code);
            this.code = value_5;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[code] is unset!");
        }
        if (args.value != null) {
            const value_6: string = args.value;
            this.value = value_6;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[value] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): SharedStruct {
        return new SharedStruct(SharedStructCodec.decode(input));
    }
    public write(output: thrift.TProtocol): void {
        return SharedStructCodec.encode(this, output);
    }
}
export interface ISharedUnion {
    option1?: string;
    option2?: string;
}
export interface ISharedUnion_Loose {
    option1?: string;
    option2?: string;
}
export const SharedUnionCodec: thrift.IStructCodec<ISharedUnion_Loose, ISharedUnion> = {
    encode(args: ISharedUnion_Loose, output: thrift.TProtocol): void {
        let _fieldsSet: number = 0;
        const obj = {
            option1: args.option1,
            option2: args.option2
        };
        output.writeStructBegin("SharedUnion");
        if (obj.option1 != null) {
            _fieldsSet++;
            output.writeFieldBegin("option1", thrift.TType.STRING, 1);
            output.writeString(obj.option1);
            output.writeFieldEnd();
        }
        if (obj.option2 != null) {
            _fieldsSet++;
            output.writeFieldBegin("option2", thrift.TType.STRING, 2);
            output.writeString(obj.option2);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        if (_fieldsSet > 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion cannot have more than one value");
        }
        else if (_fieldsSet < 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion must have one value set");
        }
        return;
    },
    decode(input: thrift.TProtocol): ISharedUnion {
        let _fieldsSet: number = 0;
        let _returnValue: ISharedUnion | null = null;
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRING) {
                        _fieldsSet++;
                        const value_7: string = input.readString();
                        _returnValue = { option1: value_7 };
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.TType.STRING) {
                        _fieldsSet++;
                        const value_8: string = input.readString();
                        _returnValue = { option2: value_8 };
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_fieldsSet > 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion cannot have more than one value");
        }
        else if (_fieldsSet < 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion must have one value set");
        }
        if (_returnValue !== null) {
            return _returnValue;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read data for TUnion");
        }
    }
};
export class SharedUnion extends thrift.StructLike  implements ISharedUnion {
    public option1?: string;
    public option2?: string;
    constructor(args: ISharedUnion_Loose = {}) {
        super();
        let _fieldsSet: number = 0;
        if (args.option1 != null) {
            _fieldsSet++;
            const value_9: string = args.option1;
            this.option1 = value_9;
        }
        if (args.option2 != null) {
            _fieldsSet++;
            const value_10: string = args.option2;
            this.option2 = value_10;
        }
        if (_fieldsSet > 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion cannot have more than one value");
        }
        else if (_fieldsSet < 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion must have one value set");
        }
    }
    public static read(input: thrift.TProtocol): SharedUnion {
        return new SharedUnion(SharedUnionCodec.decode(input));
    }
    public write(output: thrift.TProtocol): void {
        return SharedUnionCodec.encode(this, output);
    }
}
export namespace SharedService {
    export interface IGetStructArgs {
        key: number;
    }
    export interface IGetStructArgs_Loose {
        key: number;
    }
    export const GetStructArgsCodec: thrift.IStructCodec<IGetStructArgs_Loose, IGetStructArgs> = {
        encode(args: IGetStructArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                key: args.key
            };
            output.writeStructBegin("GetStructArgs");
            if (obj.key != null) {
                output.writeFieldBegin("key", thrift.TType.I32, 1);
                output.writeI32(obj.key);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[key] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IGetStructArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.I32) {
                            const value_11: number = input.readI32();
                            _args.key = value_11;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.key !== undefined) {
                return {
                    key: _args.key
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetStructArgs from input");
            }
        }
    };
    export class GetStructArgs extends thrift.StructLike  implements IGetStructArgs {
        public key: number;
        constructor(args: IGetStructArgs_Loose) {
            super();
            if (args.key != null) {
                const value_12: number = args.key;
                this.key = value_12;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[key] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): GetStructArgs {
            return new GetStructArgs(GetStructArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return GetStructArgsCodec.encode(this, output);
        }
    }
    export interface IGetUnionArgs {
        index: number;
    }
    export interface IGetUnionArgs_Loose {
        index: number;
    }
    export const GetUnionArgsCodec: thrift.IStructCodec<IGetUnionArgs_Loose, IGetUnionArgs> = {
        encode(args: IGetUnionArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                index: args.index
            };
            output.writeStructBegin("GetUnionArgs");
            if (obj.index != null) {
                output.writeFieldBegin("index", thrift.TType.I32, 1);
                output.writeI32(obj.index);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[index] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IGetUnionArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.I32) {
                            const value_13: number = input.readI32();
                            _args.index = value_13;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.index !== undefined) {
                return {
                    index: _args.index
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetUnionArgs from input");
            }
        }
    };
    export class GetUnionArgs extends thrift.StructLike  implements IGetUnionArgs {
        public index: number;
        constructor(args: IGetUnionArgs_Loose) {
            super();
            if (args.index != null) {
                const value_14: number = args.index;
                this.index = value_14;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[index] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): GetUnionArgs {
            return new GetUnionArgs(GetUnionArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return GetUnionArgsCodec.encode(this, output);
        }
    }
    export interface IGetStructResult {
        success?: ISharedStruct;
    }
    export interface IGetStructResult_Loose {
        success?: ISharedStruct_Loose;
    }
    export const GetStructResultCodec: thrift.IStructCodec<IGetStructResult_Loose, IGetStructResult> = {
        encode(args: IGetStructResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("GetStructResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
                SharedStructCodec.encode(obj.success, output);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IGetStructResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.STRUCT) {
                            const value_15: ISharedStruct = SharedStructCodec.decode(input);
                            _args.success = value_15;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class GetStructResult extends thrift.StructLike  implements IGetStructResult {
        public success?: ISharedStruct;
        constructor(args: IGetStructResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_16: ISharedStruct = new SharedStruct(args.success);
                this.success = value_16;
            }
        }
        public static read(input: thrift.TProtocol): GetStructResult {
            return new GetStructResult(GetStructResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return GetStructResultCodec.encode(this, output);
        }
    }
    export interface IGetUnionResult {
        success?: ISharedUnion;
    }
    export interface IGetUnionResult_Loose {
        success?: ISharedUnion_Loose;
    }
    export const GetUnionResultCodec: thrift.IStructCodec<IGetUnionResult_Loose, IGetUnionResult> = {
        encode(args: IGetUnionResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("GetUnionResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
                SharedUnionCodec.encode(obj.success, output);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IGetUnionResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.STRUCT) {
                            const value_17: ISharedUnion = SharedUnionCodec.decode(input);
                            _args.success = value_17;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class GetUnionResult extends thrift.StructLike  implements IGetUnionResult {
        public success?: ISharedUnion;
        constructor(args: IGetUnionResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_18: ISharedUnion = new SharedUnion(args.success);
                this.success = value_18;
            }
        }
        public static read(input: thrift.TProtocol): GetUnionResult {
            return new GetUnionResult(GetUnionResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return GetUnionResultCodec.encode(this, output);
        }
    }
    export class Client<Context = any> {
        protected _requestId: number;
        protected transport: thrift.ITransportConstructor;
        protected protocol: thrift.IProtocolConstructor;
        protected connection: thrift.IThriftConnection<Context>;
        constructor(connection: thrift.IThriftConnection<Context>) {
            this._requestId = 0;
            this.transport = connection.Transport;
            this.protocol = connection.Protocol;
            this.connection = connection;
        }
        protected incrementRequestId(): number {
            return this._requestId += 1;
        }
        public getStruct(key: number, context?: Context): Promise<ISharedStruct> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("getStruct", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IGetStructArgs_Loose = { key };
            GetStructArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "getStruct") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IGetStructResult = GetStructResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "getStruct failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public getUnion(index: number, context?: Context): Promise<ISharedUnion> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("getUnion", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IGetUnionArgs_Loose = { index };
            GetUnionArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "getUnion") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IGetUnionResult = GetUnionResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "getUnion failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
    }
    export interface IHandler<Context = any> {
        getStruct(key: number, context?: Context): ISharedStruct | Promise<ISharedStruct>;
        getUnion(index: number, context?: Context): ISharedUnion | Promise<ISharedUnion>;
    }
    export class Processor<Context = any> {
        public _handler: IHandler<Context>;
        constructor(handler: IHandler<Context>) {
            this._handler = handler;
        }
        public process(input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<Buffer>((resolve, reject): void => {
                const metadata: thrift.IThriftMessage = input.readMessageBegin();
                const fieldName: string = metadata.fieldName;
                const requestId: number = metadata.requestId;
                const methodName: string = "process_" + fieldName;
                switch (methodName) {
                    case "process_getStruct": {
                        resolve(this.process_getStruct(requestId, input, output, context));
                    }
                    case "process_getUnion": {
                        resolve(this.process_getUnion(requestId, input, output, context));
                    }
                    default: {
                        input.skip(thrift.TType.STRUCT);
                        input.readMessageEnd();
                        const errMessage = "Unknown function " + fieldName;
                        const err = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                        output.writeMessageBegin(fieldName, thrift.MessageType.EXCEPTION, requestId);
                        thrift.TApplicationExceptionCodec.encode(err, output);
                        output.writeMessageEnd();
                        resolve(output.flush());
                    }
                }
            });
        }
        public process_getStruct(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<ISharedStruct>((resolve, reject): void => {
                try {
                    const args: IGetStructArgs = GetStructArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.getStruct(args.key, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: ISharedStruct): Buffer => {
                const result: IGetStructResult = { success: data };
                output.writeMessageBegin("getStruct", thrift.MessageType.REPLY, requestId);
                GetStructResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getStruct", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_getUnion(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<ISharedUnion>((resolve, reject): void => {
                try {
                    const args: IGetUnionArgs = GetUnionArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.getUnion(args.index, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: ISharedUnion): Buffer => {
                const result: IGetUnionResult = { success: data };
                output.writeMessageBegin("getUnion", thrift.MessageType.REPLY, requestId);
                GetUnionResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getUnion", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
    }
}
