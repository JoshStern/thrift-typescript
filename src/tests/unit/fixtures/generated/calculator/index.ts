/* tslint:disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v2.0.0-11
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "@creditkarma/thrift-server-core";
import * as shared from "./../shared";
import * as common from "./../common";
import * as operation from "./../operation";
export type MyInteger = number;
export import Operation = operation.Operation;
export import ICommonStruct = common.ICommonStruct;
export import ICommonStruct_Loose = common.ICommonStruct_Loose;
export import CommonStruct = common.CommonStruct;
export import CommonStructCodec = common.CommonStructCodec;
export const INT32CONSTANT: number = 9853;
export const MAPCONSTANT: Map<string, string> = new Map([["hello", "world"], ["goodnight", "moon"]]);
export interface IWork {
    num1: number;
    num2: number;
    op: Operation;
    comment?: string;
}
export interface IWork_Loose {
    num1?: number;
    num2: number;
    op: Operation;
    comment?: string;
}
export const WorkCodec: thrift.IStructCodec<IWork_Loose, IWork> = {
    encode(args: IWork_Loose, output: thrift.TProtocol): void {
        const obj = {
            num1: (args.num1 != null ? args.num1 : 0),
            num2: args.num2,
            op: args.op,
            comment: args.comment
        };
        output.writeStructBegin("Work");
        if (obj.num1 != null) {
            output.writeFieldBegin("num1", thrift.TType.I32, 1);
            output.writeI32(obj.num1);
            output.writeFieldEnd();
        }
        if (obj.num2 != null) {
            output.writeFieldBegin("num2", thrift.TType.I32, 2);
            output.writeI32(obj.num2);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
        if (obj.op != null) {
            output.writeFieldBegin("op", thrift.TType.I32, 3);
            output.writeI32(obj.op);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[op] is unset!");
        }
        if (obj.comment != null) {
            output.writeFieldBegin("comment", thrift.TType.STRING, 4);
            output.writeString(obj.comment);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IWork {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.I32) {
                        const value_1: number = input.readI32();
                        _args.num1 = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.TType.I32) {
                        const value_2: number = input.readI32();
                        _args.num2 = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.TType.I32) {
                        const value_3: Operation = input.readI32();
                        _args.op = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.TType.STRING) {
                        const value_4: string = input.readString();
                        _args.comment = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num1 !== undefined && _args.num2 !== undefined && _args.op !== undefined) {
            return {
                num1: (_args.num1 != null ? _args.num1 : 0),
                num2: _args.num2,
                op: _args.op,
                comment: _args.comment
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read Work from input");
        }
    }
};
export class Work extends thrift.StructLike  implements IWork {
    public num1: number = 0;
    public num2: number;
    public op: Operation;
    public comment?: string;
    constructor(args: IWork_Loose) {
        super();
        if (args.num1 != null) {
            const value_5: number = args.num1;
            this.num1 = value_5;
        }
        if (args.num2 != null) {
            const value_6: number = args.num2;
            this.num2 = value_6;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
        if (args.op != null) {
            const value_7: Operation = args.op;
            this.op = value_7;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[op] is unset!");
        }
        if (args.comment != null) {
            const value_8: string = args.comment;
            this.comment = value_8;
        }
    }
    public static read(input: thrift.TProtocol): Work {
        return new Work(WorkCodec.decode(input));
    }
    public write(output: thrift.TProtocol): void {
        return WorkCodec.encode(this, output);
    }
}
export interface IFirstName {
    name?: string;
}
export interface IFirstName_Loose {
    name?: string;
}
export const FirstNameCodec: thrift.IStructCodec<IFirstName_Loose, IFirstName> = {
    encode(args: IFirstName_Loose, output: thrift.TProtocol): void {
        const obj = {
            name: args.name
        };
        output.writeStructBegin("FirstName");
        if (obj.name != null) {
            output.writeFieldBegin("name", thrift.TType.STRING, 1);
            output.writeString(obj.name);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IFirstName {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRING) {
                        const value_9: string = input.readString();
                        _args.name = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            name: _args.name
        };
    }
};
export class FirstName extends thrift.StructLike  implements IFirstName {
    public name?: string;
    constructor(args: IFirstName_Loose = {}) {
        super();
        if (args.name != null) {
            const value_10: string = args.name;
            this.name = value_10;
        }
    }
    public static read(input: thrift.TProtocol): FirstName {
        return new FirstName(FirstNameCodec.decode(input));
    }
    public write(output: thrift.TProtocol): void {
        return FirstNameCodec.encode(this, output);
    }
}
export interface ILastName {
    name?: string;
}
export interface ILastName_Loose {
    name?: string;
}
export const LastNameCodec: thrift.IStructCodec<ILastName_Loose, ILastName> = {
    encode(args: ILastName_Loose, output: thrift.TProtocol): void {
        const obj = {
            name: args.name
        };
        output.writeStructBegin("LastName");
        if (obj.name != null) {
            output.writeFieldBegin("name", thrift.TType.STRING, 1);
            output.writeString(obj.name);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ILastName {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRING) {
                        const value_11: string = input.readString();
                        _args.name = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            name: _args.name
        };
    }
};
export class LastName extends thrift.StructLike  implements ILastName {
    public name?: string;
    constructor(args: ILastName_Loose = {}) {
        super();
        if (args.name != null) {
            const value_12: string = args.name;
            this.name = value_12;
        }
    }
    public static read(input: thrift.TProtocol): LastName {
        return new LastName(LastNameCodec.decode(input));
    }
    public write(output: thrift.TProtocol): void {
        return LastNameCodec.encode(this, output);
    }
}
export interface IChoice {
    firstName?: IFirstName;
    lastName?: ILastName;
}
export interface IChoice_Loose {
    firstName?: IFirstName_Loose;
    lastName?: ILastName_Loose;
}
export const ChoiceCodec: thrift.IStructCodec<IChoice_Loose, IChoice> = {
    encode(args: IChoice_Loose, output: thrift.TProtocol): void {
        let _fieldsSet: number = 0;
        const obj = {
            firstName: args.firstName,
            lastName: args.lastName
        };
        output.writeStructBegin("Choice");
        if (obj.firstName != null) {
            _fieldsSet++;
            output.writeFieldBegin("firstName", thrift.TType.STRUCT, 1);
            FirstNameCodec.encode(obj.firstName, output);
            output.writeFieldEnd();
        }
        if (obj.lastName != null) {
            _fieldsSet++;
            output.writeFieldBegin("lastName", thrift.TType.STRUCT, 2);
            LastNameCodec.encode(obj.lastName, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        if (_fieldsSet > 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion cannot have more than one value");
        }
        else if (_fieldsSet < 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion must have one value set");
        }
        return;
    },
    decode(input: thrift.TProtocol): IChoice {
        let _fieldsSet: number = 0;
        let _returnValue: IChoice | null = null;
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        _fieldsSet++;
                        const value_13: IFirstName = FirstNameCodec.decode(input);
                        _returnValue = { firstName: value_13 };
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.TType.STRUCT) {
                        _fieldsSet++;
                        const value_14: ILastName = LastNameCodec.decode(input);
                        _returnValue = { lastName: value_14 };
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_fieldsSet > 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion cannot have more than one value");
        }
        else if (_fieldsSet < 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion must have one value set");
        }
        if (_returnValue !== null) {
            return _returnValue;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read data for TUnion");
        }
    }
};
export class Choice extends thrift.StructLike  implements IChoice {
    public firstName?: IFirstName;
    public lastName?: ILastName;
    constructor(args: IChoice_Loose = {}) {
        super();
        let _fieldsSet: number = 0;
        if (args.firstName != null) {
            _fieldsSet++;
            const value_15: IFirstName = new FirstName(args.firstName);
            this.firstName = value_15;
        }
        if (args.lastName != null) {
            _fieldsSet++;
            const value_16: ILastName = new LastName(args.lastName);
            this.lastName = value_16;
        }
        if (_fieldsSet > 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion cannot have more than one value");
        }
        else if (_fieldsSet < 1) {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.INVALID_DATA, "TUnion must have one value set");
        }
    }
    public static read(input: thrift.TProtocol): Choice {
        return new Choice(ChoiceCodec.decode(input));
    }
    public write(output: thrift.TProtocol): void {
        return ChoiceCodec.encode(this, output);
    }
}
export namespace Calculator {
    export interface IPingArgs {
    }
    export interface IPingArgs_Loose {
    }
    export const PingArgsCodec: thrift.IStructCodec<IPingArgs_Loose, IPingArgs> = {
        encode(args: IPingArgs_Loose, output: thrift.TProtocol): void {
            output.writeStructBegin("PingArgs");
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IPingArgs {
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {};
        }
    };
    export class PingArgs extends thrift.StructLike  implements IPingArgs {
        constructor(args: IPingArgs_Loose = {}) {
            super();
        }
        public static read(input: thrift.TProtocol): PingArgs {
            return new PingArgs(PingArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return PingArgsCodec.encode(this, output);
        }
    }
    export interface IAddArgs {
        num1: number;
        num2: number;
    }
    export interface IAddArgs_Loose {
        num1: number;
        num2: number;
    }
    export const AddArgsCodec: thrift.IStructCodec<IAddArgs_Loose, IAddArgs> = {
        encode(args: IAddArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                num1: args.num1,
                num2: args.num2
            };
            output.writeStructBegin("AddArgs");
            if (obj.num1 != null) {
                output.writeFieldBegin("num1", thrift.TType.I32, 1);
                output.writeI32(obj.num1);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
            }
            if (obj.num2 != null) {
                output.writeFieldBegin("num2", thrift.TType.I32, 2);
                output.writeI32(obj.num2);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IAddArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.I32) {
                            const value_17: number = input.readI32();
                            _args.num1 = value_17;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 2:
                        if (fieldType === thrift.TType.I32) {
                            const value_18: number = input.readI32();
                            _args.num2 = value_18;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.num1 !== undefined && _args.num2 !== undefined) {
                return {
                    num1: _args.num1,
                    num2: _args.num2
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddArgs from input");
            }
        }
    };
    export class AddArgs extends thrift.StructLike  implements IAddArgs {
        public num1: number;
        public num2: number;
        constructor(args: IAddArgs_Loose) {
            super();
            if (args.num1 != null) {
                const value_19: number = args.num1;
                this.num1 = value_19;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
            }
            if (args.num2 != null) {
                const value_20: number = args.num2;
                this.num2 = value_20;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): AddArgs {
            return new AddArgs(AddArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return AddArgsCodec.encode(this, output);
        }
    }
    export interface IAddInt64Args {
        num1: thrift.Int64;
        num2: thrift.Int64;
    }
    export interface IAddInt64Args_Loose {
        num1: number | thrift.Int64;
        num2: number | thrift.Int64;
    }
    export const AddInt64ArgsCodec: thrift.IStructCodec<IAddInt64Args_Loose, IAddInt64Args> = {
        encode(args: IAddInt64Args_Loose, output: thrift.TProtocol): void {
            const obj = {
                num1: (typeof args.num1 === "number" ? new thrift.Int64(args.num1) : args.num1),
                num2: (typeof args.num2 === "number" ? new thrift.Int64(args.num2) : args.num2)
            };
            output.writeStructBegin("AddInt64Args");
            if (obj.num1 != null) {
                output.writeFieldBegin("num1", thrift.TType.I64, 1);
                output.writeI64(obj.num1);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
            }
            if (obj.num2 != null) {
                output.writeFieldBegin("num2", thrift.TType.I64, 2);
                output.writeI64(obj.num2);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IAddInt64Args {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.I64) {
                            const value_21: thrift.Int64 = input.readI64();
                            _args.num1 = value_21;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 2:
                        if (fieldType === thrift.TType.I64) {
                            const value_22: thrift.Int64 = input.readI64();
                            _args.num2 = value_22;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.num1 !== undefined && _args.num2 !== undefined) {
                return {
                    num1: _args.num1,
                    num2: _args.num2
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddInt64Args from input");
            }
        }
    };
    export class AddInt64Args extends thrift.StructLike  implements IAddInt64Args {
        public num1: thrift.Int64;
        public num2: thrift.Int64;
        constructor(args: IAddInt64Args_Loose) {
            super();
            if (args.num1 != null) {
                const value_23: thrift.Int64 = (typeof args.num1 === "number" ? new thrift.Int64(args.num1) : args.num1);
                this.num1 = value_23;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
            }
            if (args.num2 != null) {
                const value_24: thrift.Int64 = (typeof args.num2 === "number" ? new thrift.Int64(args.num2) : args.num2);
                this.num2 = value_24;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): AddInt64Args {
            return new AddInt64Args(AddInt64ArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return AddInt64ArgsCodec.encode(this, output);
        }
    }
    export interface IAddWithContextArgs {
        num1: number;
        num2: number;
    }
    export interface IAddWithContextArgs_Loose {
        num1: number;
        num2: number;
    }
    export const AddWithContextArgsCodec: thrift.IStructCodec<IAddWithContextArgs_Loose, IAddWithContextArgs> = {
        encode(args: IAddWithContextArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                num1: args.num1,
                num2: args.num2
            };
            output.writeStructBegin("AddWithContextArgs");
            if (obj.num1 != null) {
                output.writeFieldBegin("num1", thrift.TType.I32, 1);
                output.writeI32(obj.num1);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
            }
            if (obj.num2 != null) {
                output.writeFieldBegin("num2", thrift.TType.I32, 2);
                output.writeI32(obj.num2);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IAddWithContextArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.I32) {
                            const value_25: number = input.readI32();
                            _args.num1 = value_25;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 2:
                        if (fieldType === thrift.TType.I32) {
                            const value_26: number = input.readI32();
                            _args.num2 = value_26;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.num1 !== undefined && _args.num2 !== undefined) {
                return {
                    num1: _args.num1,
                    num2: _args.num2
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddWithContextArgs from input");
            }
        }
    };
    export class AddWithContextArgs extends thrift.StructLike  implements IAddWithContextArgs {
        public num1: number;
        public num2: number;
        constructor(args: IAddWithContextArgs_Loose) {
            super();
            if (args.num1 != null) {
                const value_27: number = args.num1;
                this.num1 = value_27;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
            }
            if (args.num2 != null) {
                const value_28: number = args.num2;
                this.num2 = value_28;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): AddWithContextArgs {
            return new AddWithContextArgs(AddWithContextArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return AddWithContextArgsCodec.encode(this, output);
        }
    }
    export interface ICalculateArgs {
        logid: number;
        work: IWork;
    }
    export interface ICalculateArgs_Loose {
        logid: number;
        work: IWork_Loose;
    }
    export const CalculateArgsCodec: thrift.IStructCodec<ICalculateArgs_Loose, ICalculateArgs> = {
        encode(args: ICalculateArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                logid: args.logid,
                work: args.work
            };
            output.writeStructBegin("CalculateArgs");
            if (obj.logid != null) {
                output.writeFieldBegin("logid", thrift.TType.I32, 1);
                output.writeI32(obj.logid);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[logid] is unset!");
            }
            if (obj.work != null) {
                output.writeFieldBegin("work", thrift.TType.STRUCT, 2);
                WorkCodec.encode(obj.work, output);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[work] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): ICalculateArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.I32) {
                            const value_29: number = input.readI32();
                            _args.logid = value_29;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 2:
                        if (fieldType === thrift.TType.STRUCT) {
                            const value_30: IWork = WorkCodec.decode(input);
                            _args.work = value_30;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.logid !== undefined && _args.work !== undefined) {
                return {
                    logid: _args.logid,
                    work: _args.work
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CalculateArgs from input");
            }
        }
    };
    export class CalculateArgs extends thrift.StructLike  implements ICalculateArgs {
        public logid: number;
        public work: IWork;
        constructor(args: ICalculateArgs_Loose) {
            super();
            if (args.logid != null) {
                const value_31: number = args.logid;
                this.logid = value_31;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[logid] is unset!");
            }
            if (args.work != null) {
                const value_32: IWork = new Work(args.work);
                this.work = value_32;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[work] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): CalculateArgs {
            return new CalculateArgs(CalculateArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return CalculateArgsCodec.encode(this, output);
        }
    }
    export interface IEchoBinaryArgs {
        word: Buffer;
    }
    export interface IEchoBinaryArgs_Loose {
        word: string | Buffer;
    }
    export const EchoBinaryArgsCodec: thrift.IStructCodec<IEchoBinaryArgs_Loose, IEchoBinaryArgs> = {
        encode(args: IEchoBinaryArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                word: (typeof args.word === "string" ? Buffer.from(args.word) : args.word)
            };
            output.writeStructBegin("EchoBinaryArgs");
            if (obj.word != null) {
                output.writeFieldBegin("word", thrift.TType.STRING, 1);
                output.writeBinary(obj.word);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IEchoBinaryArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.STRING) {
                            const value_33: Buffer = input.readBinary();
                            _args.word = value_33;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.word !== undefined) {
                return {
                    word: _args.word
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read EchoBinaryArgs from input");
            }
        }
    };
    export class EchoBinaryArgs extends thrift.StructLike  implements IEchoBinaryArgs {
        public word: Buffer;
        constructor(args: IEchoBinaryArgs_Loose) {
            super();
            if (args.word != null) {
                const value_34: Buffer = (typeof args.word === "string" ? Buffer.from(args.word) : args.word);
                this.word = value_34;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): EchoBinaryArgs {
            return new EchoBinaryArgs(EchoBinaryArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return EchoBinaryArgsCodec.encode(this, output);
        }
    }
    export interface IEchoStringArgs {
        word: string;
    }
    export interface IEchoStringArgs_Loose {
        word: string;
    }
    export const EchoStringArgsCodec: thrift.IStructCodec<IEchoStringArgs_Loose, IEchoStringArgs> = {
        encode(args: IEchoStringArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                word: args.word
            };
            output.writeStructBegin("EchoStringArgs");
            if (obj.word != null) {
                output.writeFieldBegin("word", thrift.TType.STRING, 1);
                output.writeString(obj.word);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IEchoStringArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.STRING) {
                            const value_35: string = input.readString();
                            _args.word = value_35;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.word !== undefined) {
                return {
                    word: _args.word
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read EchoStringArgs from input");
            }
        }
    };
    export class EchoStringArgs extends thrift.StructLike  implements IEchoStringArgs {
        public word: string;
        constructor(args: IEchoStringArgs_Loose) {
            super();
            if (args.word != null) {
                const value_36: string = args.word;
                this.word = value_36;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): EchoStringArgs {
            return new EchoStringArgs(EchoStringArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return EchoStringArgsCodec.encode(this, output);
        }
    }
    export interface ICheckNameArgs {
        choice: IChoice;
    }
    export interface ICheckNameArgs_Loose {
        choice: IChoice_Loose;
    }
    export const CheckNameArgsCodec: thrift.IStructCodec<ICheckNameArgs_Loose, ICheckNameArgs> = {
        encode(args: ICheckNameArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                choice: args.choice
            };
            output.writeStructBegin("CheckNameArgs");
            if (obj.choice != null) {
                output.writeFieldBegin("choice", thrift.TType.STRUCT, 1);
                ChoiceCodec.encode(obj.choice, output);
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[choice] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): ICheckNameArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.STRUCT) {
                            const value_37: IChoice = ChoiceCodec.decode(input);
                            _args.choice = value_37;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.choice !== undefined) {
                return {
                    choice: _args.choice
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CheckNameArgs from input");
            }
        }
    };
    export class CheckNameArgs extends thrift.StructLike  implements ICheckNameArgs {
        public choice: IChoice;
        constructor(args: ICheckNameArgs_Loose) {
            super();
            if (args.choice != null) {
                const value_38: IChoice = new Choice(args.choice);
                this.choice = value_38;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[choice] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): CheckNameArgs {
            return new CheckNameArgs(CheckNameArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return CheckNameArgsCodec.encode(this, output);
        }
    }
    export interface ICheckOptionalArgs {
        type?: string;
    }
    export interface ICheckOptionalArgs_Loose {
        type?: string;
    }
    export const CheckOptionalArgsCodec: thrift.IStructCodec<ICheckOptionalArgs_Loose, ICheckOptionalArgs> = {
        encode(args: ICheckOptionalArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                type: args.type
            };
            output.writeStructBegin("CheckOptionalArgs");
            if (obj.type != null) {
                output.writeFieldBegin("type", thrift.TType.STRING, 1);
                output.writeString(obj.type);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): ICheckOptionalArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.STRING) {
                            const value_39: string = input.readString();
                            _args.type = value_39;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                type: _args.type
            };
        }
    };
    export class CheckOptionalArgs extends thrift.StructLike  implements ICheckOptionalArgs {
        public type?: string;
        constructor(args: ICheckOptionalArgs_Loose = {}) {
            super();
            if (args.type != null) {
                const value_40: string = args.type;
                this.type = value_40;
            }
        }
        public static read(input: thrift.TProtocol): CheckOptionalArgs {
            return new CheckOptionalArgs(CheckOptionalArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return CheckOptionalArgsCodec.encode(this, output);
        }
    }
    export interface IMapOneListArgs {
        arg: Array<number>;
    }
    export interface IMapOneListArgs_Loose {
        arg: Array<number>;
    }
    export const MapOneListArgsCodec: thrift.IStructCodec<IMapOneListArgs_Loose, IMapOneListArgs> = {
        encode(args: IMapOneListArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                arg: args.arg
            };
            output.writeStructBegin("MapOneListArgs");
            if (obj.arg != null) {
                output.writeFieldBegin("arg", thrift.TType.LIST, 1);
                output.writeListBegin(thrift.TType.I32, obj.arg.length);
                obj.arg.forEach((value_41: number): void => {
                    output.writeI32(value_41);
                });
                output.writeListEnd();
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IMapOneListArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.LIST) {
                            const value_42: Array<number> = new Array<number>();
                            const metadata_1: thrift.IThriftList = input.readListBegin();
                            const size_1: number = metadata_1.size;
                            for (let i_1: number = 0; i_1 < size_1; i_1++) {
                                const value_43: number = input.readI32();
                                value_42.push(value_43);
                            }
                            input.readListEnd();
                            _args.arg = value_42;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.arg !== undefined) {
                return {
                    arg: _args.arg
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MapOneListArgs from input");
            }
        }
    };
    export class MapOneListArgs extends thrift.StructLike  implements IMapOneListArgs {
        public arg: Array<number>;
        constructor(args: IMapOneListArgs_Loose) {
            super();
            if (args.arg != null) {
                const value_44: Array<number> = new Array<number>();
                args.arg.forEach((value_45: number): void => {
                    const value_46: number = value_45;
                    value_44.push(value_46);
                });
                this.arg = value_44;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): MapOneListArgs {
            return new MapOneListArgs(MapOneListArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return MapOneListArgsCodec.encode(this, output);
        }
    }
    export interface IMapValuesArgs {
        arg: Map<string, number>;
    }
    export interface IMapValuesArgs_Loose {
        arg: Map<string, number>;
    }
    export const MapValuesArgsCodec: thrift.IStructCodec<IMapValuesArgs_Loose, IMapValuesArgs> = {
        encode(args: IMapValuesArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                arg: args.arg
            };
            output.writeStructBegin("MapValuesArgs");
            if (obj.arg != null) {
                output.writeFieldBegin("arg", thrift.TType.MAP, 1);
                output.writeMapBegin(thrift.TType.STRING, thrift.TType.I32, obj.arg.size);
                obj.arg.forEach((value_47: number, key_1: string): void => {
                    output.writeString(key_1);
                    output.writeI32(value_47);
                });
                output.writeMapEnd();
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IMapValuesArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.MAP) {
                            const value_48: Map<string, number> = new Map<string, number>();
                            const metadata_2: thrift.IThriftMap = input.readMapBegin();
                            const size_2: number = metadata_2.size;
                            for (let i_2: number = 0; i_2 < size_2; i_2++) {
                                const key_2: string = input.readString();
                                const value_49: number = input.readI32();
                                value_48.set(key_2, value_49);
                            }
                            input.readMapEnd();
                            _args.arg = value_48;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.arg !== undefined) {
                return {
                    arg: _args.arg
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MapValuesArgs from input");
            }
        }
    };
    export class MapValuesArgs extends thrift.StructLike  implements IMapValuesArgs {
        public arg: Map<string, number>;
        constructor(args: IMapValuesArgs_Loose) {
            super();
            if (args.arg != null) {
                const value_50: Map<string, number> = new Map<string, number>();
                args.arg.forEach((value_51: number, key_3: string): void => {
                    const value_52: number = value_51;
                    value_50.set(key_3, value_52);
                });
                this.arg = value_50;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): MapValuesArgs {
            return new MapValuesArgs(MapValuesArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return MapValuesArgsCodec.encode(this, output);
        }
    }
    export interface IListToMapArgs {
        arg: Array<Array<string>>;
    }
    export interface IListToMapArgs_Loose {
        arg: Array<Array<string>>;
    }
    export const ListToMapArgsCodec: thrift.IStructCodec<IListToMapArgs_Loose, IListToMapArgs> = {
        encode(args: IListToMapArgs_Loose, output: thrift.TProtocol): void {
            const obj = {
                arg: args.arg
            };
            output.writeStructBegin("ListToMapArgs");
            if (obj.arg != null) {
                output.writeFieldBegin("arg", thrift.TType.LIST, 1);
                output.writeListBegin(thrift.TType.LIST, obj.arg.length);
                obj.arg.forEach((value_53: Array<string>): void => {
                    output.writeListBegin(thrift.TType.STRING, value_53.length);
                    value_53.forEach((value_54: string): void => {
                        output.writeString(value_54);
                    });
                    output.writeListEnd();
                });
                output.writeListEnd();
                output.writeFieldEnd();
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IListToMapArgs {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.TType.LIST) {
                            const value_55: Array<Array<string>> = new Array<Array<string>>();
                            const metadata_3: thrift.IThriftList = input.readListBegin();
                            const size_3: number = metadata_3.size;
                            for (let i_3: number = 0; i_3 < size_3; i_3++) {
                                const value_56: Array<string> = new Array<string>();
                                const metadata_4: thrift.IThriftList = input.readListBegin();
                                const size_4: number = metadata_4.size;
                                for (let i_4: number = 0; i_4 < size_4; i_4++) {
                                    const value_57: string = input.readString();
                                    value_56.push(value_57);
                                }
                                input.readListEnd();
                                value_55.push(value_56);
                            }
                            input.readListEnd();
                            _args.arg = value_55;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.arg !== undefined) {
                return {
                    arg: _args.arg
                };
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ListToMapArgs from input");
            }
        }
    };
    export class ListToMapArgs extends thrift.StructLike  implements IListToMapArgs {
        public arg: Array<Array<string>>;
        constructor(args: IListToMapArgs_Loose) {
            super();
            if (args.arg != null) {
                const value_58: Array<Array<string>> = new Array<Array<string>>();
                args.arg.forEach((value_59: Array<string>): void => {
                    const value_60: Array<string> = new Array<string>();
                    value_59.forEach((value_61: string): void => {
                        const value_62: string = value_61;
                        value_60.push(value_62);
                    });
                    value_58.push(value_60);
                });
                this.arg = value_58;
            }
            else {
                throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
            }
        }
        public static read(input: thrift.TProtocol): ListToMapArgs {
            return new ListToMapArgs(ListToMapArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return ListToMapArgsCodec.encode(this, output);
        }
    }
    export interface IFetchThingArgs {
    }
    export interface IFetchThingArgs_Loose {
    }
    export const FetchThingArgsCodec: thrift.IStructCodec<IFetchThingArgs_Loose, IFetchThingArgs> = {
        encode(args: IFetchThingArgs_Loose, output: thrift.TProtocol): void {
            output.writeStructBegin("FetchThingArgs");
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IFetchThingArgs {
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {};
        }
    };
    export class FetchThingArgs extends thrift.StructLike  implements IFetchThingArgs {
        constructor(args: IFetchThingArgs_Loose = {}) {
            super();
        }
        public static read(input: thrift.TProtocol): FetchThingArgs {
            return new FetchThingArgs(FetchThingArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return FetchThingArgsCodec.encode(this, output);
        }
    }
    export interface IZipArgs {
    }
    export interface IZipArgs_Loose {
    }
    export const ZipArgsCodec: thrift.IStructCodec<IZipArgs_Loose, IZipArgs> = {
        encode(args: IZipArgs_Loose, output: thrift.TProtocol): void {
            output.writeStructBegin("ZipArgs");
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IZipArgs {
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {};
        }
    };
    export class ZipArgs extends thrift.StructLike  implements IZipArgs {
        constructor(args: IZipArgs_Loose = {}) {
            super();
        }
        public static read(input: thrift.TProtocol): ZipArgs {
            return new ZipArgs(ZipArgsCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return ZipArgsCodec.encode(this, output);
        }
    }
    export interface IPingResult {
        success?: void;
    }
    export interface IPingResult_Loose {
        success?: void;
    }
    export const PingResultCodec: thrift.IStructCodec<IPingResult_Loose, IPingResult> = {
        encode(args: IPingResult_Loose, output: thrift.TProtocol): void {
            output.writeStructBegin("PingResult");
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IPingResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.VOID) {
                            input.skip(fieldType);
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class PingResult extends thrift.StructLike  implements IPingResult {
        public success?: void;
        constructor(args: IPingResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_63: void = undefined;
                this.success = value_63;
            }
        }
        public static read(input: thrift.TProtocol): PingResult {
            return new PingResult(PingResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return PingResultCodec.encode(this, output);
        }
    }
    export interface IAddResult {
        success?: number;
        exp?: operation.IJankyResult;
    }
    export interface IAddResult_Loose {
        success?: number;
        exp?: operation.IJankyResult_Loose;
    }
    export const AddResultCodec: thrift.IStructCodec<IAddResult_Loose, IAddResult> = {
        encode(args: IAddResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success,
                exp: args.exp
            };
            output.writeStructBegin("AddResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.I32, 0);
                output.writeI32(obj.success);
                output.writeFieldEnd();
            }
            if (obj.exp != null) {
                output.writeFieldBegin("exp", thrift.TType.STRUCT, 1);
                operation.JankyResultCodec.encode(obj.exp, output);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IAddResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.I32) {
                            const value_64: number = input.readI32();
                            _args.success = value_64;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 1:
                        if (fieldType === thrift.TType.STRUCT) {
                            const value_65: operation.IJankyResult = operation.JankyResultCodec.decode(input);
                            _args.exp = value_65;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success,
                exp: _args.exp
            };
        }
    };
    export class AddResult extends thrift.StructLike  implements IAddResult {
        public success?: number;
        public exp?: operation.IJankyResult;
        constructor(args: IAddResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_66: number = args.success;
                this.success = value_66;
            }
            if (args.exp != null) {
                const value_67: operation.IJankyResult = new operation.JankyResult(args.exp);
                this.exp = value_67;
            }
        }
        public static read(input: thrift.TProtocol): AddResult {
            return new AddResult(AddResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return AddResultCodec.encode(this, output);
        }
    }
    export interface IAddInt64Result {
        success?: thrift.Int64;
    }
    export interface IAddInt64Result_Loose {
        success?: number | thrift.Int64;
    }
    export const AddInt64ResultCodec: thrift.IStructCodec<IAddInt64Result_Loose, IAddInt64Result> = {
        encode(args: IAddInt64Result_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: (typeof args.success === "number" ? new thrift.Int64(args.success) : args.success)
            };
            output.writeStructBegin("AddInt64Result");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.I64, 0);
                output.writeI64(obj.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IAddInt64Result {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.I64) {
                            const value_68: thrift.Int64 = input.readI64();
                            _args.success = value_68;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class AddInt64Result extends thrift.StructLike  implements IAddInt64Result {
        public success?: thrift.Int64;
        constructor(args: IAddInt64Result_Loose = {}) {
            super();
            if (args.success != null) {
                const value_69: thrift.Int64 = (typeof args.success === "number" ? new thrift.Int64(args.success) : args.success);
                this.success = value_69;
            }
        }
        public static read(input: thrift.TProtocol): AddInt64Result {
            return new AddInt64Result(AddInt64ResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return AddInt64ResultCodec.encode(this, output);
        }
    }
    export interface IAddWithContextResult {
        success?: number;
    }
    export interface IAddWithContextResult_Loose {
        success?: number;
    }
    export const AddWithContextResultCodec: thrift.IStructCodec<IAddWithContextResult_Loose, IAddWithContextResult> = {
        encode(args: IAddWithContextResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("AddWithContextResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.I32, 0);
                output.writeI32(obj.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IAddWithContextResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.I32) {
                            const value_70: number = input.readI32();
                            _args.success = value_70;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class AddWithContextResult extends thrift.StructLike  implements IAddWithContextResult {
        public success?: number;
        constructor(args: IAddWithContextResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_71: number = args.success;
                this.success = value_71;
            }
        }
        public static read(input: thrift.TProtocol): AddWithContextResult {
            return new AddWithContextResult(AddWithContextResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return AddWithContextResultCodec.encode(this, output);
        }
    }
    export interface ICalculateResult {
        success?: number;
        ouch?: operation.IJankyOperation;
    }
    export interface ICalculateResult_Loose {
        success?: number;
        ouch?: operation.IJankyOperation_Loose;
    }
    export const CalculateResultCodec: thrift.IStructCodec<ICalculateResult_Loose, ICalculateResult> = {
        encode(args: ICalculateResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success,
                ouch: args.ouch
            };
            output.writeStructBegin("CalculateResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.I32, 0);
                output.writeI32(obj.success);
                output.writeFieldEnd();
            }
            if (obj.ouch != null) {
                output.writeFieldBegin("ouch", thrift.TType.STRUCT, 1);
                operation.JankyOperationCodec.encode(obj.ouch, output);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): ICalculateResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.I32) {
                            const value_72: number = input.readI32();
                            _args.success = value_72;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 1:
                        if (fieldType === thrift.TType.STRUCT) {
                            const value_73: operation.IJankyOperation = operation.JankyOperationCodec.decode(input);
                            _args.ouch = value_73;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success,
                ouch: _args.ouch
            };
        }
    };
    export class CalculateResult extends thrift.StructLike  implements ICalculateResult {
        public success?: number;
        public ouch?: operation.IJankyOperation;
        constructor(args: ICalculateResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_74: number = args.success;
                this.success = value_74;
            }
            if (args.ouch != null) {
                const value_75: operation.IJankyOperation = new operation.JankyOperation(args.ouch);
                this.ouch = value_75;
            }
        }
        public static read(input: thrift.TProtocol): CalculateResult {
            return new CalculateResult(CalculateResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return CalculateResultCodec.encode(this, output);
        }
    }
    export interface IEchoBinaryResult {
        success?: string;
    }
    export interface IEchoBinaryResult_Loose {
        success?: string;
    }
    export const EchoBinaryResultCodec: thrift.IStructCodec<IEchoBinaryResult_Loose, IEchoBinaryResult> = {
        encode(args: IEchoBinaryResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("EchoBinaryResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.STRING, 0);
                output.writeString(obj.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IEchoBinaryResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.STRING) {
                            const value_76: string = input.readString();
                            _args.success = value_76;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class EchoBinaryResult extends thrift.StructLike  implements IEchoBinaryResult {
        public success?: string;
        constructor(args: IEchoBinaryResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_77: string = args.success;
                this.success = value_77;
            }
        }
        public static read(input: thrift.TProtocol): EchoBinaryResult {
            return new EchoBinaryResult(EchoBinaryResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return EchoBinaryResultCodec.encode(this, output);
        }
    }
    export interface IEchoStringResult {
        success?: string;
    }
    export interface IEchoStringResult_Loose {
        success?: string;
    }
    export const EchoStringResultCodec: thrift.IStructCodec<IEchoStringResult_Loose, IEchoStringResult> = {
        encode(args: IEchoStringResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("EchoStringResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.STRING, 0);
                output.writeString(obj.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IEchoStringResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.STRING) {
                            const value_78: string = input.readString();
                            _args.success = value_78;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class EchoStringResult extends thrift.StructLike  implements IEchoStringResult {
        public success?: string;
        constructor(args: IEchoStringResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_79: string = args.success;
                this.success = value_79;
            }
        }
        public static read(input: thrift.TProtocol): EchoStringResult {
            return new EchoStringResult(EchoStringResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return EchoStringResultCodec.encode(this, output);
        }
    }
    export interface ICheckNameResult {
        success?: string;
    }
    export interface ICheckNameResult_Loose {
        success?: string;
    }
    export const CheckNameResultCodec: thrift.IStructCodec<ICheckNameResult_Loose, ICheckNameResult> = {
        encode(args: ICheckNameResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("CheckNameResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.STRING, 0);
                output.writeString(obj.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): ICheckNameResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.STRING) {
                            const value_80: string = input.readString();
                            _args.success = value_80;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class CheckNameResult extends thrift.StructLike  implements ICheckNameResult {
        public success?: string;
        constructor(args: ICheckNameResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_81: string = args.success;
                this.success = value_81;
            }
        }
        public static read(input: thrift.TProtocol): CheckNameResult {
            return new CheckNameResult(CheckNameResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return CheckNameResultCodec.encode(this, output);
        }
    }
    export interface ICheckOptionalResult {
        success?: string;
    }
    export interface ICheckOptionalResult_Loose {
        success?: string;
    }
    export const CheckOptionalResultCodec: thrift.IStructCodec<ICheckOptionalResult_Loose, ICheckOptionalResult> = {
        encode(args: ICheckOptionalResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("CheckOptionalResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.STRING, 0);
                output.writeString(obj.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): ICheckOptionalResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.STRING) {
                            const value_82: string = input.readString();
                            _args.success = value_82;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class CheckOptionalResult extends thrift.StructLike  implements ICheckOptionalResult {
        public success?: string;
        constructor(args: ICheckOptionalResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_83: string = args.success;
                this.success = value_83;
            }
        }
        public static read(input: thrift.TProtocol): CheckOptionalResult {
            return new CheckOptionalResult(CheckOptionalResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return CheckOptionalResultCodec.encode(this, output);
        }
    }
    export interface IMapOneListResult {
        success?: Array<number>;
    }
    export interface IMapOneListResult_Loose {
        success?: Array<number>;
    }
    export const MapOneListResultCodec: thrift.IStructCodec<IMapOneListResult_Loose, IMapOneListResult> = {
        encode(args: IMapOneListResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("MapOneListResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.LIST, 0);
                output.writeListBegin(thrift.TType.I32, obj.success.length);
                obj.success.forEach((value_84: number): void => {
                    output.writeI32(value_84);
                });
                output.writeListEnd();
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IMapOneListResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.LIST) {
                            const value_85: Array<number> = new Array<number>();
                            const metadata_5: thrift.IThriftList = input.readListBegin();
                            const size_5: number = metadata_5.size;
                            for (let i_5: number = 0; i_5 < size_5; i_5++) {
                                const value_86: number = input.readI32();
                                value_85.push(value_86);
                            }
                            input.readListEnd();
                            _args.success = value_85;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class MapOneListResult extends thrift.StructLike  implements IMapOneListResult {
        public success?: Array<number>;
        constructor(args: IMapOneListResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_87: Array<number> = new Array<number>();
                args.success.forEach((value_88: number): void => {
                    const value_89: number = value_88;
                    value_87.push(value_89);
                });
                this.success = value_87;
            }
        }
        public static read(input: thrift.TProtocol): MapOneListResult {
            return new MapOneListResult(MapOneListResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return MapOneListResultCodec.encode(this, output);
        }
    }
    export interface IMapValuesResult {
        success?: Array<number>;
    }
    export interface IMapValuesResult_Loose {
        success?: Array<number>;
    }
    export const MapValuesResultCodec: thrift.IStructCodec<IMapValuesResult_Loose, IMapValuesResult> = {
        encode(args: IMapValuesResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("MapValuesResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.LIST, 0);
                output.writeListBegin(thrift.TType.I32, obj.success.length);
                obj.success.forEach((value_90: number): void => {
                    output.writeI32(value_90);
                });
                output.writeListEnd();
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IMapValuesResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.LIST) {
                            const value_91: Array<number> = new Array<number>();
                            const metadata_6: thrift.IThriftList = input.readListBegin();
                            const size_6: number = metadata_6.size;
                            for (let i_6: number = 0; i_6 < size_6; i_6++) {
                                const value_92: number = input.readI32();
                                value_91.push(value_92);
                            }
                            input.readListEnd();
                            _args.success = value_91;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class MapValuesResult extends thrift.StructLike  implements IMapValuesResult {
        public success?: Array<number>;
        constructor(args: IMapValuesResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_93: Array<number> = new Array<number>();
                args.success.forEach((value_94: number): void => {
                    const value_95: number = value_94;
                    value_93.push(value_95);
                });
                this.success = value_93;
            }
        }
        public static read(input: thrift.TProtocol): MapValuesResult {
            return new MapValuesResult(MapValuesResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return MapValuesResultCodec.encode(this, output);
        }
    }
    export interface IListToMapResult {
        success?: Map<string, string>;
    }
    export interface IListToMapResult_Loose {
        success?: Map<string, string>;
    }
    export const ListToMapResultCodec: thrift.IStructCodec<IListToMapResult_Loose, IListToMapResult> = {
        encode(args: IListToMapResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("ListToMapResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.MAP, 0);
                output.writeMapBegin(thrift.TType.STRING, thrift.TType.STRING, obj.success.size);
                obj.success.forEach((value_96: string, key_4: string): void => {
                    output.writeString(key_4);
                    output.writeString(value_96);
                });
                output.writeMapEnd();
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IListToMapResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.MAP) {
                            const value_97: Map<string, string> = new Map<string, string>();
                            const metadata_7: thrift.IThriftMap = input.readMapBegin();
                            const size_7: number = metadata_7.size;
                            for (let i_7: number = 0; i_7 < size_7; i_7++) {
                                const key_5: string = input.readString();
                                const value_98: string = input.readString();
                                value_97.set(key_5, value_98);
                            }
                            input.readMapEnd();
                            _args.success = value_97;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class ListToMapResult extends thrift.StructLike  implements IListToMapResult {
        public success?: Map<string, string>;
        constructor(args: IListToMapResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_99: Map<string, string> = new Map<string, string>();
                args.success.forEach((value_100: string, key_6: string): void => {
                    const value_101: string = value_100;
                    value_99.set(key_6, value_101);
                });
                this.success = value_99;
            }
        }
        public static read(input: thrift.TProtocol): ListToMapResult {
            return new ListToMapResult(ListToMapResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return ListToMapResultCodec.encode(this, output);
        }
    }
    export interface IFetchThingResult {
        success?: common.ICommonStruct;
    }
    export interface IFetchThingResult_Loose {
        success?: common.ICommonStruct_Loose;
    }
    export const FetchThingResultCodec: thrift.IStructCodec<IFetchThingResult_Loose, IFetchThingResult> = {
        encode(args: IFetchThingResult_Loose, output: thrift.TProtocol): void {
            const obj = {
                success: args.success
            };
            output.writeStructBegin("FetchThingResult");
            if (obj.success != null) {
                output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
                common.CommonStructCodec.encode(obj.success, output);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IFetchThingResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.STRUCT) {
                            const value_102: common.ICommonStruct = common.CommonStructCodec.decode(input);
                            _args.success = value_102;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class FetchThingResult extends thrift.StructLike  implements IFetchThingResult {
        public success?: common.ICommonStruct;
        constructor(args: IFetchThingResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_103: common.ICommonStruct = new common.CommonStruct(args.success);
                this.success = value_103;
            }
        }
        public static read(input: thrift.TProtocol): FetchThingResult {
            return new FetchThingResult(FetchThingResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return FetchThingResultCodec.encode(this, output);
        }
    }
    export interface IZipResult {
        success?: void;
    }
    export interface IZipResult_Loose {
        success?: void;
    }
    export const ZipResultCodec: thrift.IStructCodec<IZipResult_Loose, IZipResult> = {
        encode(args: IZipResult_Loose, output: thrift.TProtocol): void {
            output.writeStructBegin("ZipResult");
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        },
        decode(input: thrift.TProtocol): IZipResult {
            let _args: any = {};
            input.readStructBegin();
            while (true) {
                const ret: thrift.IThriftField = input.readFieldBegin();
                const fieldType: thrift.TType = ret.fieldType;
                const fieldId: number = ret.fieldId;
                if (fieldType === thrift.TType.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.TType.VOID) {
                            input.skip(fieldType);
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return {
                success: _args.success
            };
        }
    };
    export class ZipResult extends thrift.StructLike  implements IZipResult {
        public success?: void;
        constructor(args: IZipResult_Loose = {}) {
            super();
            if (args.success != null) {
                const value_104: void = undefined;
                this.success = value_104;
            }
        }
        public static read(input: thrift.TProtocol): ZipResult {
            return new ZipResult(ZipResultCodec.decode(input));
        }
        public write(output: thrift.TProtocol): void {
            return ZipResultCodec.encode(this, output);
        }
    }
    export class Client<Context = any> extends shared.SharedService.Client<Context> {
        protected _requestId: number;
        protected transport: thrift.ITransportConstructor;
        protected protocol: thrift.IProtocolConstructor;
        protected connection: thrift.IThriftConnection<Context>;
        constructor(connection: thrift.IThriftConnection<Context>) {
            super(connection);
            this._requestId = 0;
            this.transport = connection.Transport;
            this.protocol = connection.Protocol;
            this.connection = connection;
        }
        protected incrementRequestId(): number {
            return this._requestId += 1;
        }
        public ping(context?: Context): Promise<void> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("ping", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IPingArgs_Loose = {};
            PingArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "ping") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IPingResult = PingResultCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.resolve(result.success);
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public add(num1: number, num2: number, context?: Context): Promise<number> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("add", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IAddArgs_Loose = { num1, num2 };
            AddArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "add") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IAddResult = AddResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.exp != null) {
                            return Promise.reject(result.exp);
                        }
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "add failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public addInt64(num1: number | thrift.Int64, num2: number | thrift.Int64, context?: Context): Promise<thrift.Int64> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("addInt64", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IAddInt64Args_Loose = { num1, num2 };
            AddInt64ArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "addInt64") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IAddInt64Result = AddInt64ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "addInt64 failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public addWithContext(num1: number, num2: number, context?: Context): Promise<number> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("addWithContext", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IAddWithContextArgs_Loose = { num1, num2 };
            AddWithContextArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "addWithContext") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IAddWithContextResult = AddWithContextResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "addWithContext failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public calculate(logid: number, work: IWork_Loose, context?: Context): Promise<number> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("calculate", thrift.MessageType.CALL, this.incrementRequestId());
            const args: ICalculateArgs_Loose = { logid, work };
            CalculateArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "calculate") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: ICalculateResult = CalculateResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.ouch != null) {
                            return Promise.reject(result.ouch);
                        }
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "calculate failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public echoBinary(word: string | Buffer, context?: Context): Promise<string> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("echoBinary", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IEchoBinaryArgs_Loose = { word };
            EchoBinaryArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "echoBinary") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IEchoBinaryResult = EchoBinaryResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "echoBinary failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public echoString(word: string, context?: Context): Promise<string> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("echoString", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IEchoStringArgs_Loose = { word };
            EchoStringArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "echoString") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IEchoStringResult = EchoStringResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "echoString failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public checkName(choice: IChoice_Loose, context?: Context): Promise<string> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("checkName", thrift.MessageType.CALL, this.incrementRequestId());
            const args: ICheckNameArgs_Loose = { choice };
            CheckNameArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "checkName") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: ICheckNameResult = CheckNameResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "checkName failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public checkOptional(type?: string, context?: Context): Promise<string> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("checkOptional", thrift.MessageType.CALL, this.incrementRequestId());
            const args: ICheckOptionalArgs_Loose = { type };
            CheckOptionalArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "checkOptional") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: ICheckOptionalResult = CheckOptionalResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "checkOptional failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public mapOneList(arg: Array<number>, context?: Context): Promise<Array<number>> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("mapOneList", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IMapOneListArgs_Loose = { arg };
            MapOneListArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "mapOneList") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IMapOneListResult = MapOneListResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "mapOneList failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public mapValues(arg: Map<string, number>, context?: Context): Promise<Array<number>> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("mapValues", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IMapValuesArgs_Loose = { arg };
            MapValuesArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "mapValues") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IMapValuesResult = MapValuesResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "mapValues failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public listToMap(arg: Array<Array<string>>, context?: Context): Promise<Map<string, string>> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("listToMap", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IListToMapArgs_Loose = { arg };
            ListToMapArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "listToMap") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IListToMapResult = ListToMapResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "listToMap failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public fetchThing(context?: Context): Promise<common.ICommonStruct> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("fetchThing", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IFetchThingArgs_Loose = {};
            FetchThingArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "fetchThing") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IFetchThingResult = FetchThingResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "fetchThing failed: unknown result"));
                        }
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
        public zip(context?: Context): Promise<void> {
            const writer: thrift.TTransport = new this.transport();
            const output: thrift.TProtocol = new this.protocol(writer);
            output.writeMessageBegin("zip", thrift.MessageType.CALL, this.incrementRequestId());
            const args: IZipArgs_Loose = {};
            ZipArgsCodec.encode(args, output);
            output.writeMessageEnd();
            return this.connection.send(writer.flush(), context).then((data: Buffer) => {
                const reader: thrift.TTransport = this.transport.receiver(data);
                const input: thrift.TProtocol = new this.protocol(reader);
                try {
                    const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                    if (fieldName === "zip") {
                        if (messageType === thrift.MessageType.EXCEPTION) {
                            const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                            input.readMessageEnd();
                            return Promise.reject(err);
                        }
                        const result: IZipResult = ZipResultCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.resolve(result.success);
                    }
                    else {
                        return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            });
        }
    }
    export interface ILocalHandler<Context = any> {
        ping(context?: Context): void | Promise<void>;
        add(num1: number, num2: number, context?: Context): number | Promise<number>;
        addInt64(num1: thrift.Int64, num2: thrift.Int64, context?: Context): thrift.Int64 | Promise<thrift.Int64>;
        addWithContext(num1: number, num2: number, context?: Context): number | Promise<number>;
        calculate(logid: number, work: IWork, context?: Context): number | Promise<number>;
        echoBinary(word: Buffer, context?: Context): string | Promise<string>;
        echoString(word: string, context?: Context): string | Promise<string>;
        checkName(choice: IChoice, context?: Context): string | Promise<string>;
        checkOptional(type?: string, context?: Context): string | Promise<string>;
        mapOneList(arg: Array<number>, context?: Context): Array<number> | Promise<Array<number>>;
        mapValues(arg: Map<string, number>, context?: Context): Array<number> | Promise<Array<number>>;
        listToMap(arg: Array<Array<string>>, context?: Context): Map<string, string> | Promise<Map<string, string>>;
        fetchThing(context?: Context): common.ICommonStruct | Promise<common.ICommonStruct>;
        zip(context?: Context): void | Promise<void>;
    }
    export type IHandler<Context = any> = ILocalHandler<Context> & shared.SharedService.IHandler<Context>;
    export class Processor<Context = any> extends shared.SharedService.Processor<Context> {
        public _handler: IHandler<Context>;
        constructor(handler: IHandler<Context>) {
            super({
                getStruct: handler.getStruct,
                getUnion: handler.getUnion
            });
            this._handler = handler;
        }
        public process(input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<Buffer>((resolve, reject): void => {
                const metadata: thrift.IThriftMessage = input.readMessageBegin();
                const fieldName: string = metadata.fieldName;
                const requestId: number = metadata.requestId;
                const methodName: string = "process_" + fieldName;
                switch (methodName) {
                    case "process_getStruct": {
                        resolve(this.process_getStruct(requestId, input, output, context));
                    }
                    case "process_getUnion": {
                        resolve(this.process_getUnion(requestId, input, output, context));
                    }
                    case "process_ping": {
                        resolve(this.process_ping(requestId, input, output, context));
                    }
                    case "process_add": {
                        resolve(this.process_add(requestId, input, output, context));
                    }
                    case "process_addInt64": {
                        resolve(this.process_addInt64(requestId, input, output, context));
                    }
                    case "process_addWithContext": {
                        resolve(this.process_addWithContext(requestId, input, output, context));
                    }
                    case "process_calculate": {
                        resolve(this.process_calculate(requestId, input, output, context));
                    }
                    case "process_echoBinary": {
                        resolve(this.process_echoBinary(requestId, input, output, context));
                    }
                    case "process_echoString": {
                        resolve(this.process_echoString(requestId, input, output, context));
                    }
                    case "process_checkName": {
                        resolve(this.process_checkName(requestId, input, output, context));
                    }
                    case "process_checkOptional": {
                        resolve(this.process_checkOptional(requestId, input, output, context));
                    }
                    case "process_mapOneList": {
                        resolve(this.process_mapOneList(requestId, input, output, context));
                    }
                    case "process_mapValues": {
                        resolve(this.process_mapValues(requestId, input, output, context));
                    }
                    case "process_listToMap": {
                        resolve(this.process_listToMap(requestId, input, output, context));
                    }
                    case "process_fetchThing": {
                        resolve(this.process_fetchThing(requestId, input, output, context));
                    }
                    case "process_zip": {
                        resolve(this.process_zip(requestId, input, output, context));
                    }
                    default: {
                        input.skip(thrift.TType.STRUCT);
                        input.readMessageEnd();
                        const errMessage = "Unknown function " + fieldName;
                        const err = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                        output.writeMessageBegin(fieldName, thrift.MessageType.EXCEPTION, requestId);
                        thrift.TApplicationExceptionCodec.encode(err, output);
                        output.writeMessageEnd();
                        resolve(output.flush());
                    }
                }
            });
        }
        public process_ping(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<void>((resolve, reject): void => {
                try {
                    input.readMessageEnd();
                    resolve(this._handler.ping(context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: void): Buffer => {
                const result: IPingResult = { success: data };
                output.writeMessageBegin("ping", thrift.MessageType.REPLY, requestId);
                PingResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("ping", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_add(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<number>((resolve, reject): void => {
                try {
                    const args: IAddArgs = AddArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.add(args.num1, args.num2, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: number): Buffer => {
                const result: IAddResult = { success: data };
                output.writeMessageBegin("add", thrift.MessageType.REPLY, requestId);
                AddResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                if (err instanceof operation.JankyResult) {
                    const result: IAddResult = { exp: err };
                    output.writeMessageBegin("add", thrift.MessageType.REPLY, requestId);
                    AddResultCodec.encode(result, output);
                    output.writeMessageEnd();
                    return output.flush();
                }
                else {
                    const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                    output.writeMessageBegin("add", thrift.MessageType.EXCEPTION, requestId);
                    thrift.TApplicationExceptionCodec.encode(result, output);
                    output.writeMessageEnd();
                    return output.flush();
                }
            });
        }
        public process_addInt64(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<thrift.Int64>((resolve, reject): void => {
                try {
                    const args: IAddInt64Args = AddInt64ArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.addInt64(args.num1, args.num2, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: thrift.Int64): Buffer => {
                const result: IAddInt64Result = { success: data };
                output.writeMessageBegin("addInt64", thrift.MessageType.REPLY, requestId);
                AddInt64ResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addInt64", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_addWithContext(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<number>((resolve, reject): void => {
                try {
                    const args: IAddWithContextArgs = AddWithContextArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.addWithContext(args.num1, args.num2, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: number): Buffer => {
                const result: IAddWithContextResult = { success: data };
                output.writeMessageBegin("addWithContext", thrift.MessageType.REPLY, requestId);
                AddWithContextResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addWithContext", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_calculate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<number>((resolve, reject): void => {
                try {
                    const args: ICalculateArgs = CalculateArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.calculate(args.logid, args.work, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: number): Buffer => {
                const result: ICalculateResult = { success: data };
                output.writeMessageBegin("calculate", thrift.MessageType.REPLY, requestId);
                CalculateResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                if (err instanceof operation.JankyOperation) {
                    const result: ICalculateResult = { ouch: err };
                    output.writeMessageBegin("calculate", thrift.MessageType.REPLY, requestId);
                    CalculateResultCodec.encode(result, output);
                    output.writeMessageEnd();
                    return output.flush();
                }
                else {
                    const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                    output.writeMessageBegin("calculate", thrift.MessageType.EXCEPTION, requestId);
                    thrift.TApplicationExceptionCodec.encode(result, output);
                    output.writeMessageEnd();
                    return output.flush();
                }
            });
        }
        public process_echoBinary(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<string>((resolve, reject): void => {
                try {
                    const args: IEchoBinaryArgs = EchoBinaryArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.echoBinary(args.word, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: string): Buffer => {
                const result: IEchoBinaryResult = { success: data };
                output.writeMessageBegin("echoBinary", thrift.MessageType.REPLY, requestId);
                EchoBinaryResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("echoBinary", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_echoString(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<string>((resolve, reject): void => {
                try {
                    const args: IEchoStringArgs = EchoStringArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.echoString(args.word, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: string): Buffer => {
                const result: IEchoStringResult = { success: data };
                output.writeMessageBegin("echoString", thrift.MessageType.REPLY, requestId);
                EchoStringResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("echoString", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_checkName(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<string>((resolve, reject): void => {
                try {
                    const args: ICheckNameArgs = CheckNameArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.checkName(args.choice, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: string): Buffer => {
                const result: ICheckNameResult = { success: data };
                output.writeMessageBegin("checkName", thrift.MessageType.REPLY, requestId);
                CheckNameResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("checkName", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_checkOptional(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<string>((resolve, reject): void => {
                try {
                    const args: ICheckOptionalArgs = CheckOptionalArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.checkOptional(args.type, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: string): Buffer => {
                const result: ICheckOptionalResult = { success: data };
                output.writeMessageBegin("checkOptional", thrift.MessageType.REPLY, requestId);
                CheckOptionalResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("checkOptional", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_mapOneList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<Array<number>>((resolve, reject): void => {
                try {
                    const args: IMapOneListArgs = MapOneListArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.mapOneList(args.arg, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: Array<number>): Buffer => {
                const result: IMapOneListResult = { success: data };
                output.writeMessageBegin("mapOneList", thrift.MessageType.REPLY, requestId);
                MapOneListResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("mapOneList", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_mapValues(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<Array<number>>((resolve, reject): void => {
                try {
                    const args: IMapValuesArgs = MapValuesArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.mapValues(args.arg, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: Array<number>): Buffer => {
                const result: IMapValuesResult = { success: data };
                output.writeMessageBegin("mapValues", thrift.MessageType.REPLY, requestId);
                MapValuesResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("mapValues", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_listToMap(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<Map<string, string>>((resolve, reject): void => {
                try {
                    const args: IListToMapArgs = ListToMapArgsCodec.decode(input);
                    input.readMessageEnd();
                    resolve(this._handler.listToMap(args.arg, context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: Map<string, string>): Buffer => {
                const result: IListToMapResult = { success: data };
                output.writeMessageBegin("listToMap", thrift.MessageType.REPLY, requestId);
                ListToMapResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("listToMap", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_fetchThing(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<common.ICommonStruct>((resolve, reject): void => {
                try {
                    input.readMessageEnd();
                    resolve(this._handler.fetchThing(context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: common.ICommonStruct): Buffer => {
                const result: IFetchThingResult = { success: data };
                output.writeMessageBegin("fetchThing", thrift.MessageType.REPLY, requestId);
                FetchThingResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("fetchThing", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
        public process_zip(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
            return new Promise<void>((resolve, reject): void => {
                try {
                    input.readMessageEnd();
                    resolve(this._handler.zip(context));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: void): Buffer => {
                const result: IZipResult = { success: data };
                output.writeMessageBegin("zip", thrift.MessageType.REPLY, requestId);
                ZipResultCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            }).catch((err: Error): Buffer => {
                const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("zip", thrift.MessageType.EXCEPTION, requestId);
                thrift.TApplicationExceptionCodec.encode(result, output);
                output.writeMessageEnd();
                return output.flush();
            });
        }
    }
}
